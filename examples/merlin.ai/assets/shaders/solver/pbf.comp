//?#version 430

#pragma once
//?#include "../common/uniforms.comp"
//?#include "../common/constants.comp"
//?#include "../common/buffers.comp"
//?#include "../common/colors.comp"
//?#include "../common/nns.comp"
//?#include "sph.kernels.comp" 
//?#include "boundary.comp" 

float pbf_computeLambda(uint i);
vec3 pbf_computePositionDelta(uint i);
vec3 pbf_computeXPSH(uint i);
vec3 computeLavaViscosity(uint i);

//#define USE_ONLY_POSITIVE_PRESSURE

vec3 solveParticleCollision(uint i){
	
	vec3 deltaPosition = vec3(0);
	vec3 xi = b_pi.xyz;
	vec3 position = xi;
	int n = 0;

	OVERNNS
		if(!(phase(j) >= BOUNDARY /*|| phase(j) == SOLID*/)) continue;
		if(i == j) continue;
		float dist = c_Dij;
		if(dist < EPSILON && dist > H) continue;

		vec3 xj = b_xj.xyz;

		float ri, rj;
		ri = rj = cst_particleRadius * 1.0;
		
		// Compute the constraint C
		vec3 xij = xi - xj;
		
		float C = dist - (ri + rj);
		

		//if (C < 0.0) { // Only apply correction if there is a collision
			// Compute the gradient of the constraint
			//vec3 grad_i = xij / dist;
			vec3 grad_i = normalize(xij);
			vec3 grad_j = -grad_i;

			// Compute the Lagrange multiplier update
			float wi = 1.0 / mi;
			float wj = 1.0 / mj;
			//float grad_norm2 = wi * dot(grad_i, grad_i) + wj * dot(grad_j, grad_j); //Magnitude or gradient are 1 so it simplify
			float grad_norm2 = wi + wj;
			float alpha = 0.0001; // Compliance parameter, should be set appropriately
			
			//float delta_lambda = -(C + alpha * b_lambda_j) / (grad_norm2 + alpha);
			float delta_lambda = -C / (grad_norm2 + alpha);
			//b_lambda_j += delta_lambda;

			// Apply position corrections
			deltaPosition = wi * delta_lambda * grad_i;
			n++;
		//}

	OVERNNS_END

	//if(n > 1) deltaPosition = deltaPosition/float(n);

	float relaxation = 0.1;

	return relaxation * deltaPosition;
}

void pbf_step(uint i, uint kernel) {
	if(kernel == 0){
		b_last_xi = b_xi;
		b_xi = b_pi;
		vec3 a = vec3(0, 0, -u_g);

		//semi-implicit Euler integration (or Sympletic scheme)
		b_vi.xyz += a * u_dt;
		b_pi.xyz += 0.998*b_vi.xyz * u_dt;

		return;
	}

	if(kernel == 1){ //compute lagrange multiplier
		//b_lambda_i = clamp(pbf_computeLambda(i), -0.1*H, 0.1*H);
		b_lambda_i = pbf_computeLambda(i);
		return;
	}
		
	if(kernel == 2){//correct density error and update position
		b_dpi.xyz = pbf_computePositionDelta(i);
		//b_dpi.xyz += solveParticleCollision(i);
		b_dpi.xyz += boundary_solveFloorCollision(i);
		


		//particles[i].pposition = clampToDomain(particles[i].pposition);
		return;
	}

	if(kernel == 3){//apply XSPH velocity correction
		vec3 corr = b_dpi.xyz;
		if(isnan(corr.x) || isnan(corr.y) || isnan(corr.z)) corr = vec3(0);

		b_pi.xyz += corr;

		//b_vi.xyz = (b_pi.xyz - b_xi.xyz)/u_dt; // First order velocity update
		b_vi.xyz = (1.0/u_dt) * (1.5*b_pi.xyz - 2.0* b_xi.xyz + 0.5*b_last_xi.xyz); // Second order velocity update
		b_vi.xyz = boundary_dampFloorCollision(i);
		
		//sigma_i = mat4(visco_computeViscoStress(i));
		return;
	}


	if(kernel == 1){ //compute lagrange multiplier
		//b_lambda_i = clamp(pbf_computeLambda(i), -0.1*H, 0.1*H);
		b_lambda_i = pbf_computeLambda(i);
		return;
	}
		
	if(kernel == 2){//correct density error and update position
		b_dpi.xyz = pbf_computePositionDelta(i);
		//b_dpi.xyz += solveParticleCollision(i);
		b_dpi.xyz += boundary_solveFloorCollision(i);
		
		//particles[i].pposition = clampToDomain(particles[i].pposition);
		return;
	}

	if(kernel == 4){//apply XSPH velocity correction
		b_dpi.xyz = pbf_computeXPSH(i)/* + computeLavaViscosity(i)*/;
		return;
	}

	if(kernel == 5){//apply XSPH velocity correction
		b_vi.xyz += b_dpi.xyz;
		if(b_xi.z < 3.0*cst_particleRadius) b_vi.xyz *= 0.1;
		return;
	}
}

vec3 pbf_computeXPSH(uint i){
	vec3 xsphSum = vec3(0);
	vec3 position = b_pi.xyz;

	OVERNNS
		if(j == i) continue;
		float dist = c_Dij;
		if(dist < EPSILON || dist > H) continue;
		float Wij = poly6(c_Rij);

		if(b_rho_j < EPSILON) continue;
		vec3 xsph = vec3(0);
		if(phase(j) == FLUID || phase(j) == SOLID){
			//xsphSum += (mj/b_rho_j) * c_Vji * Wij;
			xsph = u_artificialViscosityMultiplier * c_Vji * Wij / b_rho_j;
		}else if(phase(j) == BOUNDARY){
			//xsphSum += 0.3*(1.0/b_rho_j) * c_Vji * Wij;
			//xsph = 0.3 * c_Vji * Wij / b_rho_j;
			xsph = u_artificialViscosityMultiplier * c_Vji * Wij;
			//xsph = u_artificialViscosityMultiplier *0.001 * c_Vji * Wij / b_rho_j;
		}else if(phase(j) == BOUNDARY+1){
			//xsphSum += 0.3*(1.0/b_rho_j) * c_Vji * Wij;
			//xsph = 0.3* c_Vji * Wij / b_rho_j;
			//xsph = 5.0*u_artificialViscosityMultiplier * c_Vji * Wij / b_rho_j;
			xsph =30.0*u_artificialViscosityMultiplier * c_Vji * Wij;
		}
		xsphSum += xsph;
	OVERNNS_END

	//float thermal_visco = u_artificialViscosityMultiplier * ((275 + 400)/b_Ti) + 0.002;

	//xsphSum *= u_artificialViscosityMultiplier;

	const float maxValue = 300.0*H;
	xsphSum.x = clamp(xsphSum.x, -maxValue, maxValue);
	xsphSum.y = clamp(xsphSum.y, -maxValue, maxValue);
	xsphSum.z = clamp(xsphSum.z, -maxValue, maxValue);
	return xsphSum;
}




float pbf_computeLambda(uint i) {
    float rho0 = u_rho0;
    float sumGradCj = 0;
    vec3 gradCi = vec3(0);
    float density = 0.0;
    vec3 position = b_xi.xyz;

    OVERNNS
		float dist = c_Dij;
		if(dist > H) continue;

		vec3 diff = c_Rij;
		vec3 gradCj = spiky_grad(diff);

		if(phase(j) == FLUID || phase(j) == SOLID){
			gradCi += mj * gradCj;
		}/*
		else if (phase(j) == SOLID){
			if(b_rho_j > EPSILON)
			gradCi += 20.0*mj * gradCj;
		}*/else if (phase(j) >= BOUNDARY){
			if(b_rho_j > EPSILON)
				gradCi +=(1.0/b_rho_j) * gradCj;
		}/**/
		
		if(i != j && dist > EPSILON){
			if(phase(j) == FLUID|| phase(j) == SOLID){
				sumGradCj += dot(gradCj, gradCj);
				density += mj * poly6(dist);
			}
			/*
			else if (phase(j) == SOLID){
				density += 10.0 * 0.7*(rho0/b_rho_j) * 2.0 * poly6(dist);
				vec3 gradCk = 10.0*(1.0/b_rho_j) * 2.0 *  gradCj;
				sumGradCj += dot(gradCk, gradCk);
			}*/
			else if (phase(j) >= BOUNDARY){
				density += 0.2* poly6(dist);
				if(b_rho_j > EPSILON){

					density += 0.1*(rho0/b_rho_j) * poly6(dist);
					vec3 gradCk = (1.0/b_rho_j) * gradCj;
					sumGradCj += dot(gradCk, gradCk);
					
				}
			}/**/
		}
		
	OVERNNS_END



	sumGradCj += dot(gradCi, gradCi);
	sumGradCj = max(sumGradCj, EPSILON);

	#ifdef USE_ONLY_POSITIVE_PRESSURE
		b_rho_i = max(density, rho0);
		float C = max((density / rho0) - 1.0, 0.0);
	#else
		b_rho_i = density;
		float C = (density / rho0) - 1.0;
	#endif

	    //return - ((1.0/mi) * C) / (sumGradCj/pow(rho0, 2) + EPSILON);
    //return -C / (sumGradCj/pow(rho0, 2) + EPSILON);
	float compliance = 0.00001;
	float alpha = compliance / (u_dt*u_dt);   // e.g. compliance = 1e-6
	return -C / (sumGradCj + alpha + EPSILON);
}




//Compute position deltas w neigbor
vec3 pbf_computePositionDelta(uint i) {
	vec3 posDelta = vec3(0.0f);
	float rho0 = u_rho0;
	float sCorr = 0.0;
	
	#ifdef USE_ONLY_POSITIVE_PRESSURE
		if(b_rho_i -  u_rho0 < 0) return posDelta;
	#endif

	//float closestSDF = 0.0;
	//float closestSDF_distance = 10000.0;
	//vec3 closestSDF_grad = vec3(0);
	
	vec3 sumSDFGrad = vec3(0.0);
	float sumSDFWeight = 0.0;
	uint numNeihbors = 0;

	vec3 position = b_xi.xyz;
	OVERNNS
		//if(j == i) continue;
		float dist = c_Dij;
		if(dist > H || dist < EPSILON) continue;

		sCorr = -u_artificialPressureMultiplier * H2 * pow(poly6(dist) / poly6(normalize(vec3(1)) * 0.2*H), 4);
		//sCorr = -u_artificialPressureMultiplier * pow(poly6(dist) / poly6(normalize(vec3(1)) * 0.2*H), 4);

		if(phase(j) == FLUID || phase(j) == SOLID){
			//posDelta += (spiky_grad(c_Rij) * (b_lambda_i + b_lambda_j + sCorr)) / rho0;
			
			if(j != i)
				posDelta += spiky_grad(c_Rij) * (b_lambda_i + b_lambda_j + sCorr);
			else 
				posDelta += spiky_grad(c_Rij) * (b_lambda_i + b_lambda_i + sCorr);
			
		}else if( phase(j) >= BOUNDARY && sCorr <0){
			if(j != i && spiky(c_Rij) > 0)
				posDelta += 0.5*spiky_grad(c_Rij) * (b_lambda_i + sCorr);

			//SDF Correction averaging
			//vec4 sdf = b_dpj;
			
			//sumSDFWeight += b_dpj.w * poly6(c_Dij);
			

			/*
			if(c_Dij < closestSDF_distance) {
				closestSDF = b_dpj.w;
				closestSDF_grad = b_dpj.xyz;
				closestSDF_distance = c_Dij;
			}/**/
			
			/**/
			if(c_Dij > 0.2*H) {
				numNeihbors ++;
				sumSDFGrad += b_dpj.xyz * poly6(c_Dij); // push out
				sumSDFWeight += b_dpj.w;
			}/**/



		}else if(phase(j) == SOLID){
			if(j != i)
				posDelta += 1.0*spiky_grad(c_Rij) * (b_lambda_i + 0.0*sCorr);
		}
		/*
		else if(phase(j) == SOLID){
			posDelta += 0.1*spiky_grad(c_Rij) * (1.0/b_rho_j) * (2.0 * b_lambda_i + sCorr);
		}
		else if(phase(j) >= BOUNDARY){
			posDelta += 0.1*spiky_grad(c_Rij) * (1.0/b_rho_j) * (2.0 * b_lambda_i + sCorr);
		}/**/

	OVERNNS_END
	posDelta /= rho0;

	//SDF Correction
	float stiffness = 2.0; // 0 = no correction, 1 = full projection
	sumSDFWeight /= float(numNeihbors);

	if (sumSDFWeight > 0.0) {
	//if (closestSDF > 0.0) {
		posDelta -= stiffness * normalize(sumSDFGrad) * sumSDFWeight;
		//posDelta -= stiffness * normalize(closestSDF_grad) * closestSDF;
	}

	//posDelta = clamp(posDelta, -MAX_DELTA_PI, MAX_DELTA_PI);
	return posDelta * 0.2;
}
