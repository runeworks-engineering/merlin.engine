#include "Slicer.h"
#include <Merlin.h>
#include <iomanip>
#include <sstream>
#include <ctime>
#include <fstream>





Slicer::Slicer()
    : toolpath(0), noTool({ -1,0,10000,0 }) {

    start_gcode = {
        "T-1",
        "G28",
        "G29",
        "G29 S1",
        "G1 Z5 F5000",
        "G10 S220 R215 P0",
        "G10 S230 R235 P1",
        "M190 S60",
        "T1 P0",
        "M116",
        "T0 P0",
        "M116",
        "T-1",
        "T0",
        "G21",
        "G90",
        "M83",
        "G92 E0",
        "M107"
    };

    end_gcode = {
        "G1 E-0.8 F2400",
        "M107",
        "G91",
        "G1 Z2 F1000",
        "G90",
        "T-1",
        "G29 S2",
        "G28 X0",
        "M0",
        "M84",
        "M73 P100 R0"
    };
    clear();
}

void Slicer::clear() {
    gcode.clear();
    toolpath.clear();
    post_processed_gcode.clear();
    m_current_position = glm::vec4(0, 0, 0, 0);
    m_last_tool = noTool;
    m_active_tool = noTool;

    actual_max_z = 0;
    numLayers = 0;
    filament_diameter = 1.75;

    m_cumulative_E = 0;
    m_current_feedrate = 1000;
}

void Slicer::load_macro(const std::string& start_path, const std::string& end_path) {
    // Load start gcode
    if (!start_path.empty()) {
        std::ifstream start_file(start_path);
        if (start_file) {
            std::vector<std::string> loaded_start_gcode;
            std::string line;
            while (std::getline(start_file, line)) {
                if (!line.empty()) loaded_start_gcode.push_back(line);
            }
            if (!loaded_start_gcode.empty()) {
                start_gcode = loaded_start_gcode;
            }
        }
    }

    // Load end gcode
    if (!end_path.empty()) {
        std::ifstream end_file(end_path);
        if (end_file) {
            std::vector<std::string> loaded_end_gcode;
            std::string line;
            while (std::getline(end_file, line)) {
                if (!line.empty()) loaded_end_gcode.push_back(line);
            }
            if (!loaded_end_gcode.empty()) {
                end_gcode = loaded_end_gcode;
            }
        }
    }
}

void Slicer::slice() {
    process();
}

void Slicer::process() {
    //append comment header with props settings, use prop.xxx for each samples
    comment("-----------------------------------");
    comment("Generated by Merlin Slicer");
    comment("Filament Diameter: " + std::to_string(filament_diameter) + "mm");
    comment("Number of Layers: " + std::to_string(numLayers));
    comment("-----------------------------------");
    add_gcode("\n");

    //add marcos gcode to the post_processed_gcode before export
    post_processed_gcode.clear();
    for (const auto& line : start_gcode) {
        post_processed_gcode.push_back(line);
    }
    add_gcode("\n");
    // Ajoute le G-code généré principal
    for (const auto& line : gcode) {
        post_processed_gcode.push_back(line);
    }
    add_gcode("\n");
    // Ajoute le end_gcode à la fin
    for (const auto& line : end_gcode) {
        post_processed_gcode.push_back(line);
    }
}

void Slicer::postprocess() {
    // Placeholder for any post-processing steps
}

void Slicer::generateSample(SampleProperty props) {
    Tool tool;

    tool.id = props.tool;
    tool.flowrate = props.flow;
    tool.retract_length = props.retract;
    tool.feedrate = props.feedrate;

    add_gcode("\n");
    comment("-----------------------");
    comment("Start of Sample");
    // Append comment header with props settings
    comment("Sample Name: " + props.name);
    comment("Sample Comment: " + props.comment);
    comment("Filament Diameter: " + std::to_string(filament_diameter) + "mm");
    comment("Number of Layers: " + std::to_string(numLayers));
    comment("X Offset: " + std::to_string(props.x_offset));
    comment("Y Offset: " + std::to_string(props.y_offset));
    comment("Radius: " + std::to_string(props.radius));
    comment("Height: " + std::to_string(props.height));
    comment("Layer Height: " + std::to_string(props.layer_height));
    comment("Line Width: " + std::to_string(props.line_width));
    comment("Tool ID: " + std::to_string(props.tool));
    comment("Flow: " + std::to_string(props.flow));
    comment("Retract: " + std::to_string(props.retract));
    comment("Feedrate: " + std::to_string(props.feedrate));
    comment("Use concentric: " + std::to_string(props.use_concentric));
    comment("Use outline: " + std::to_string(props.use_outline));
    comment("-----------------------");
    add_gcode("\n");

    for (int layer = 0; layer < numLayers; ++layer) {
        float z = props.layer_height * (layer + 1);

        retract(1, 2400);
        new_layer(z);

        retract(1.4, 2400);
        move(glm::vec4(props.x_offset, props.y_offset, actual_max_z + 5, 0), 0, 30000);
        move(glm::vec4(m_current_position.x, m_current_position.y, z, 0), 17800);
        extrude(1.4, 2400);

        if (props.use_concentric) generateConcentric(props);
        else generateSpiral(props);

        // PLA Section
        retract(1, 2400);
    }

    retract(1, 2400);
    comment("End of Sample");
}

void Slicer::generateSpiral(SampleProperty props){
    float a = 0.0f;
    float pi = glm::pi<float>();
    float b = props.line_width / (2.0f * pi);
    float theta = 0.0f;
    float r = pi / 12.0f;


    // First spiral arm
    while (true) {
        float dTheta = props.resolution * (r / props.radius) / std::sqrt(b * b + std::pow(b * theta, 2));
        theta += dTheta;
        r = a + b * theta;

        if (props.use_outline) {
            if (r + props.line_width > props.radius) break;
        }
        else {
            if (r > props.radius) break;
        }

        glm::vec3 next = glm::vec3(r * std::cos(theta), r * std::sin(theta), m_current_position.z);
        float e = compute_e(glm::distance(glm::vec3(m_current_position), next), props.flow, props.line_width, props.layer_height);
        move(glm::vec4(next, e));
    }

    // Outer ring if outline is used
    if (props.use_outline) {
        float dTheta = props.resolution / (4.0f * props.radius) / std::sqrt(b * b + std::pow(b * theta, 2));
        float ring_radius = props.radius - props.line_width * 0.2f;

        for (float gamma = theta; gamma < theta + 2.0f * pi; gamma += dTheta) {
            float x = ring_radius * std::cos(gamma);
            float y = ring_radius * std::sin(gamma);
            

            glm::vec3 next = glm::vec3(x, y, m_current_position.z);
            float e = compute_e(glm::distance(glm::vec3(m_current_position), next), props.flow, props.line_width, props.layer_height);
            move(glm::vec4(next, e));
        }
    }
}

void Slicer::generateConcentric(SampleProperty props){

    int n = static_cast<int>(props.radius / props.line_width);
    float alpha = 0.0f;
    float pi = glm::pi<float>();
    for (int i = 0; i < n; ++i) {
        if (alpha == 0.0f) {
            alpha += props.line_width;
            continue;
        }

        float inc = std::asin(props.resolution * 0.5f / alpha);
        for (float theta = 0.0f; theta < 2.0f * pi; theta += inc) {
            float x = std::cos(theta) * alpha;
            float y = std::sin(theta) * alpha;

            glm::vec3 next = glm::vec3(x, y, m_current_position.z);
            float e = compute_e(glm::distance(glm::vec3(m_current_position), next), props.flow, props.line_width, props.layer_height);
            move(glm::vec4(next, e));
        }

        alpha += props.line_width;
    }  
}

float Slicer::compute_e(float length, float flow, float line_width, float layer_height) const {
    float filament_area = glm::pi<float>() * pow((filament_diameter / 2.0), 2.0);
    float base_e_per_mm = (line_width * layer_height) / filament_area;
    return base_e_per_mm * flow * length;
}

std::string Slicer::time() const {
    std::ostringstream oss;
    auto t = std::time(nullptr);
    auto tm = *std::localtime(&t);
    oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
    return oss.str();
}

void Slicer::comment(const std::string& comment) {
    gcode.push_back("; " + comment);
}

void Slicer::add_gcode(const std::string& cmd) {
    gcode.push_back(cmd);
}

void Slicer::export_gcode(const std::string& filename) {
    if (post_processed_gcode.empty()) process();
    if (post_processed_gcode.empty()) return;

    std::ofstream out(filename);
    for (const auto& line : post_processed_gcode) {
        out << line << "\n";
    }
    out.close();

    Merlin::Console::info() << "GCode successfully written to " << filename << Merlin::Console::endl;
}

void Slicer::retract(float length, float feedrate_override) {
    glm::vec4 end = m_current_position;
    end.w = -length;
    move(end, feedrate_override);
}

void Slicer::extrude(float length, float feedrate_override) {
    glm::vec4 end = m_current_position;
    end.w = length;
    move(end, feedrate_override);
}

void Slicer::move(glm::vec4 destination, int mode, float feedrate_override) {
    glm::vec4 start = m_current_position;
    glm::vec4 end = destination;
    ToolPath tp = gen_toolpath(start, end, m_active_tool, feedrate_override, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::tool_change(Tool tool) {
    
    if (m_active_tool.id == tool.id) return;

    m_active_tool = tool;
    retract(1.4, 2400);
    move_Z(actual_max_z + 5, 0, 30000);
    add_gcode("T" + std::to_string(tool.id));
    brush();
    ToolPath tpa = gen_toolpath(m_current_position, glm::vec4(330, 240, m_current_position.z, 0), m_active_tool, 30000);
    ToolPath tpb = gen_toolpath(m_current_position, glm::vec4(330, 240, m_current_position.z, 0), m_active_tool, 30000);
    m_current_position = glm::vec4(330, 240, m_current_position.z, 0);
    toolpath.push_back(tpa);
    toolpath.push_back(tpb);
}

void Slicer::move_Z(float destination, int mode, float feedrate) {
    glm::vec4 dest = m_current_position;
    dest.z = destination;
    ToolPath tp = gen_toolpath(m_current_position, dest, m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::moveXY(glm::vec2 destination, int mode, float feedrate) {
    ToolPath tp = gen_toolpath(m_current_position, glm::vec4(destination.x, destination.y, m_current_position.z, 0), m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::moveXYE(glm::vec2 destination, float e, int mode, float feedrate) {
    ToolPath tp = gen_toolpath(m_current_position, glm::vec4(destination.x, destination.y, m_current_position.z, e), m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

int Slicer::getLayer() const{
    return m_current_layer;
}

void Slicer::new_layer(float z) {
    glm::vec4 start = m_current_position;
    glm::vec4 end = m_current_position;
    end.w = 0;
    end.z = z;
    actual_max_z = z > actual_max_z ? z : actual_max_z;

    m_current_layer++;
    ToolPath tp = gen_toolpath(start, end, m_active_tool, m_current_feedrate, 0);
    add_gcode(tp);

    //m_sliced_object.push_back(m_current_layer);
    //m_current_layer.clear();
}

void Slicer::brush() {
    move_Z(actual_max_z + 5, 0);
    add_gcode("M98 Pbrush.g");
    ToolPath tp2 = gen_toolpath(m_current_position, glm::vec4(335, 100, m_current_position.z, 0), m_active_tool, 10000, 0);
    ToolPath tp3 = gen_toolpath(m_current_position, glm::vec4(335, 180, m_current_position.z, 0), m_active_tool, 10000, 0);
    toolpath.push_back(tp2);
    toolpath.push_back(tp3);
    m_current_position = glm::vec4(330, 180, m_current_position.z, 0);
}

ToolPath Slicer::gen_toolpath(const glm::vec4& start, const glm::vec4& end, const Tool& tool, float feedrate_override, int mode) {
    ToolPath tp = ToolPath();
    tp.start = start;
    tp.end = end;

    tp.meta.x = feedrate_override == -1 ? tool.feedrate : feedrate_override;
    tp.meta.y = 0;
    tp.meta.z = tool.flowrate;
    tp.meta.w = tool.id;
    tp.meta_bis.x = m_current_layer;
    tp.meta_bis.y = mode;
    return tp;
}

void Slicer::add_gcode(ToolPath tp, const std::string& command) {
    std::ostringstream line;
    line << command << " ";

    if (tp.end.x != m_current_position.x) line << "X" << std::fixed << std::setprecision(3) << tp.end.x << " ";
    if (tp.end.y != m_current_position.y) line << "Y" << std::fixed << std::setprecision(3) << std::to_string(tp.end.y) + " ";
    if (tp.end.z != m_current_position.z) line << "Z" << std::fixed << std::setprecision(3) << std::to_string(tp.end.z) + " ";
    if (tp.end.w != 0) line << "E" << std::fixed << std::setprecision(5) << std::to_string(tp.end.w) + " ";
    if (tp.meta.x != m_current_feedrate) line << "F" << std::to_string(int(tp.meta.x)) + " ";

    if (line.str() == command + " ") return;
    m_current_position = tp.end;
    m_current_position.w = 0;
    m_current_feedrate = tp.meta.x;
    gcode.push_back(line.str());
    toolpath.push_back(tp);
}