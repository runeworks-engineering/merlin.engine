#include "Slicer.h"
#include <Merlin.h>
#include <iomanip>
#include <sstream>
#include <ctime>
#include <fstream>





Slicer::Slicer()
    : toolpath(0), noTool({ -1,0,10000,0 }) {

    start_gcode = {};
    end_gcode = {};
    clear();
}

void Slicer::clear() {
    gcode.clear();
    toolpath.clear();
    post_processed_gcode.clear();
    m_current_position = glm::vec4(0, 0, 0, 0);
    m_last_tool = noTool;
    m_active_tool = noTool;

    actual_max_z = 0;
    numLayers = 0;
    m_current_layer = 0;
    filament_diameter = 1.75;

    m_cumulative_E = 0;
    m_current_feedrate = 0;
}

void Slicer::load_macro(const std::string& start_path, const std::string& end_path) {
    // Load start gcode
    if (!start_path.empty()) {
        std::ifstream start_file(start_path);
        if (start_file) {
            std::vector<std::string> loaded_start_gcode;
            std::string line;
            while (std::getline(start_file, line)) {
                if (!line.empty()) loaded_start_gcode.push_back(line);
            }
            if (!loaded_start_gcode.empty()) {
                start_gcode = loaded_start_gcode;
            }
        }
    }

    // Load end gcode
    if (!end_path.empty()) {
        std::ifstream end_file(end_path);
        if (end_file) {
            std::vector<std::string> loaded_end_gcode;
            std::string line;
            while (std::getline(end_file, line)) {
                if (!line.empty()) loaded_end_gcode.push_back(line);
            }
            if (!loaded_end_gcode.empty()) {
                end_gcode = loaded_end_gcode;
            }
        }
    }
}

void Slicer::slice() {
    process();
}

void Slicer::process() {
    //append comment header with props settings, use prop.xxx for each samples
    comment("-----------------------------------");
    comment("Generated by Merlin Slicer");
    comment("Filament Diameter: " + std::to_string(filament_diameter) + "mm");
    comment("Number of Layers: " + std::to_string(numLayers));
    comment("-----------------------------------");
    add_gcode("\n");

    //add marcos gcode to the post_processed_gcode before export
    post_processed_gcode.clear();
    for (const auto& line : start_gcode) {
        post_processed_gcode.push_back(line);
    }
    add_gcode("\n");
    // Ajoute le G-code généré principal
    for (const auto& line : gcode) {
        post_processed_gcode.push_back(line);
    }
    add_gcode("\n");
    // Ajoute le end_gcode à la fin
    for (const auto& line : end_gcode) {
        post_processed_gcode.push_back(line);
    }
}

void Slicer::postprocess() {
    // Placeholder for any post-processing steps
}

glm::vec2 rotate2D(glm::vec2 v, float rotation) {
    float s = sin(rotation);
    float c = cos(rotation);
    glm::vec2 cpy = v;
    v.x = cpy.x * c - cpy.y * s;
    v.y = cpy.y * c + cpy.x * s;
    return v;
}

void Slicer::generateSample(SampleProperty props) {
    Tool tool;

    tool.id = 0;
    tool.flowrate = props.flow;
    tool.retract_length = 0;
    tool.feedrate = props.feedrate;

    m_active_tool = tool;

    numLayers = (int) ceil(props.height / props.layer_height);

    add_gcode("\n");
    comment("-----------------------");
    comment("Start of Sample");
    // Append comment header with props settings
    comment("Sample Name: " + props.name);
    comment("Sample Comment: " + props.comment);
    comment("Filament Diameter: " + std::to_string(filament_diameter) + "mm");
    comment("Number of Layers: " + std::to_string(numLayers));
    comment("X Offset: " + std::to_string(props.x_position));
    comment("Y Offset: " + std::to_string(props.y_position));
    comment("Rotation Z: " + std::to_string(props.rotation_z));
    comment("Length: " + std::to_string(props.length));
    comment("Width: " + std::to_string(props.width));
    comment("Height: " + std::to_string(props.height));
    comment("Layer Height: " + std::to_string(props.layer_height));
    comment("Line Width: " + std::to_string(props.line_width));
    comment("Flow: " + std::to_string(props.flow));
    comment("Feedrate: " + std::to_string(props.feedrate));
    comment("-----------------------");
    add_gcode("\n");

    for (int layer = 0; layer < numLayers; ++layer) {
        float z = props.layer_height * (layer + 1);
        
        // Compute corners position (with rotation)
        float dx = props.length * 0.5f - props.line_width * 0.5f;
        float dy = props.width * 0.5f - props.line_width * 0.5f;
        float theta = props.rotation_z * DEG_TO_RAD;
        float gamma = 45 * DEG_TO_RAD;
        glm::vec2 center = glm::vec2(props.x_position, props.y_position);

        glm::vec2 A = rotate2D(glm::vec2(-dx, -dy), theta) + center;
        glm::vec2 B = rotate2D(glm::vec2(+dx, -dy), theta) + center;
        glm::vec2 C = rotate2D(glm::vec2(+dx, +dy), theta) + center;
        glm::vec2 D = rotate2D(glm::vec2(-dx, +dy), theta) + center;

        new_layer(z);
        move(glm::vec4(props.x_position, props.y_position, actual_max_z + 5, 0), 0, 1000);
      
        // Perimeter (rectangle)
        float e_perim = compute_e(props.length, props.flow, props.line_width, props.layer_height);
        float e_perim_y = compute_e(props.width, props.flow, props.line_width, props.layer_height);

        move(glm::vec4(A, 0, 3), 0); //move and prime
        move_Z(z); //move and prime
        moveXYE(B, e_perim, 1);
        moveXYE(C, e_perim_y, 1);
        moveXYE(D, e_perim, 1);
        moveXYE(A, e_perim_y, 1);
        retract(3);
        move_Z(m_current_position.z + 5, 0);
        
        
        //Rectilinear infill 100%
        float infill_spacing = props.line_width;
        int num_lines = static_cast<int>(props.width / infill_spacing) - 1;

        glm::vec2 tangent = glm::normalize(B - A);
        glm::vec2 normal = glm::normalize(glm::cross(glm::vec3(tangent, 0), glm::vec3(0,0,-1)));
        float line_length = props.length - props.line_width * 1.5; //remove perimeter

        glm::vec2 lineStart = A + tangent * props.line_width*0.5f + normal * props.line_width * 0.5f;
        glm::vec2 lineEnd = A + tangent * line_length + normal * props.line_width * 0.5f;
        moveXY(lineStart, 0); // Aller au coin bas-gauche
        move_Z(z); // Aller au coin bas-gauche

        for (int i = 0; i <= num_lines; ++i) {
                
            float e_infill = compute_e(line_length, props.flow, props.line_width, props.layer_height);

            if (i % 2 == 0) {
                moveXYE(lineEnd, e_infill, 1); // Extrusion ligne
                lineEnd += normal * props.line_width;
                lineStart += normal * props.line_width;
                moveXYE(lineEnd, 0, 1); // Extrusion ligne

            }
            else {
                moveXYE(lineStart, e_infill, 1);
                lineStart += normal * props.line_width;
                lineEnd += normal * props.line_width;
                moveXYE(lineStart, 0, 1);
            }
                
        }/**/
        retract(-3);
        move_Z(z + 5); // Aller au coin bas-gauche
        


    }

 
    comment("-----------------------");
    comment("     End of Sample");
    comment("-----------------------");

}


float Slicer::compute_e(float length, float flow, float line_width, float layer_height) const {
    float filament_area = glm::pi<float>() * pow((filament_diameter / 2.0), 2.0);
    float base_e_per_mm = (line_width * layer_height) / filament_area;
    return base_e_per_mm * flow * length;
}

std::string Slicer::time() const {
    std::ostringstream oss;
    auto t = std::time(nullptr);
    auto tm = *std::localtime(&t);
    oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
    return oss.str();
}

void Slicer::comment(const std::string& comment) {
    gcode.push_back("; " + comment);
}

void Slicer::add_gcode(const std::string& cmd) {
    gcode.push_back(cmd);
}

void Slicer::export_gcode(const std::string& filename) {
    if (post_processed_gcode.empty()) process();
    if (post_processed_gcode.empty()) return;

    std::ofstream out(filename);
    for (const auto& line : post_processed_gcode) {
        out << line << "\n";
    }
    out.close();

    Merlin::Console::info() << "GCode successfully written to " << filename << Merlin::Console::endl;
}

const std::vector<std::string>& Slicer::get_gcode(){
    return post_processed_gcode;
}

void Slicer::retract(float length, float feedrate_override) {
    glm::vec4 end = m_current_position;
    end.w = -length;
    move(end, feedrate_override);
}

void Slicer::extrude(float length, float feedrate_override) {
    glm::vec4 end = m_current_position;
    end.w = length;
    move(end, feedrate_override);
}

void Slicer::move(glm::vec4 destination, int mode, float feedrate_override) {
    glm::vec4 start = m_current_position;
    glm::vec4 end = destination;
    ToolPath tp = gen_toolpath(start, end, m_active_tool, feedrate_override, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::tool_change(Tool tool) {
    
    if (m_active_tool.id == tool.id) return;

    m_active_tool = tool;
    retract(1.4, 2400);
    move_Z(actual_max_z + 5, 0, 30000);
    add_gcode("T" + std::to_string(tool.id));
    brush();
    ToolPath tpa = gen_toolpath(m_current_position, glm::vec4(330, 240, m_current_position.z, 0), m_active_tool, 30000);
    ToolPath tpb = gen_toolpath(m_current_position, glm::vec4(330, 240, m_current_position.z, 0), m_active_tool, 30000);
    m_current_position = glm::vec4(330, 240, m_current_position.z, 0);
    toolpath.push_back(tpa);
    toolpath.push_back(tpb);
}

void Slicer::move_Z(float destination, int mode, float feedrate) {
    glm::vec4 dest = m_current_position;
    dest.z = destination;
    ToolPath tp = gen_toolpath(m_current_position, dest, m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::moveXY(glm::vec2 destination, int mode, float feedrate) {
    ToolPath tp = gen_toolpath(m_current_position, glm::vec4(destination.x, destination.y, m_current_position.z, 0), m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::moveXYE(glm::vec2 destination, float e, int mode, float feedrate) {
    ToolPath tp = gen_toolpath(m_current_position, glm::vec4(destination.x, destination.y, m_current_position.z, e), m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

int Slicer::getLayer() const{
    return m_current_layer;
}

int Slicer::getLayerCount() const {
    return numLayers;
}

void Slicer::new_layer(float z) {
    glm::vec4 start = m_current_position;
    glm::vec4 end = m_current_position;
    end.w = 0;
    end.z = z;
    actual_max_z = z > actual_max_z ? z : actual_max_z;

    m_current_layer++;
    ToolPath tp = gen_toolpath(start, end, m_active_tool, m_active_tool.feedrate, 0);
    add_gcode(tp);

    //m_sliced_object.push_back(m_current_layer);
    //m_current_layer.clear();
}

void Slicer::brush() {
    move_Z(actual_max_z + 5, 0);
    add_gcode("M98 Pbrush.g");
    ToolPath tp2 = gen_toolpath(m_current_position, glm::vec4(335, 100, m_current_position.z, 0), m_active_tool, 10000, 0);
    ToolPath tp3 = gen_toolpath(m_current_position, glm::vec4(335, 180, m_current_position.z, 0), m_active_tool, 10000, 0);
    toolpath.push_back(tp2);
    toolpath.push_back(tp3);
    m_current_position = glm::vec4(330, 180, m_current_position.z, 0);
}

ToolPath Slicer::gen_toolpath(const glm::vec4& start, const glm::vec4& end, const Tool& tool, float feedrate_override, int mode) {
    ToolPath tp = ToolPath();
    tp.start = start;
    tp.end = end;

    tp.meta.x = feedrate_override == -1 ? tool.feedrate : feedrate_override;
    tp.meta.y = 0;
    tp.meta.z = tool.flowrate;
    tp.meta.w = tool.id;
    tp.meta_bis.x = m_current_layer;
    tp.meta_bis.y = mode;
    return tp;
}

void Slicer::add_gcode(ToolPath tp, const std::string& command) {
    std::ostringstream line;
    line << command << " ";

    if (tp.end.x != m_current_position.x) line << "X" << std::fixed << std::setprecision(3) << tp.end.x << " ";
    if (tp.end.y != m_current_position.y) line << "Y" << std::fixed << std::setprecision(3) << std::to_string(tp.end.y) + " ";
    if (tp.end.z != m_current_position.z) line << "Z" << std::fixed << std::setprecision(3) << std::to_string(tp.end.z) + " ";
    if (tp.end.w != 0) line << "E" << std::fixed << std::setprecision(5) << std::to_string(tp.end.w) + " ";
    if (tp.meta.x != m_current_feedrate) line << "F" << std::to_string(int(tp.meta.x)) + " ";

    if (line.str() == command + " ") return;
    m_current_position = tp.end;
    m_current_position.w = 0;
    m_current_feedrate = tp.meta.x;
    gcode.push_back(line.str());
    toolpath.push_back(tp);
}