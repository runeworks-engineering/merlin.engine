#include "Slicer.h"
#include <Merlin.h>
#include <iomanip>
#include <sstream>
#include <ctime>
#include <fstream>





Slicer::Slicer()
    : toolpath(0), noTool({ -1,0,0,10000,0 }) {

    start_gcode = {
        "T-1",
        "G28",
        "G29",
        "G29 S1",
        "G1 Z5 F5000",
        "G10 S220 R215 P0",
        "G10 S230 R235 P1",
        "M190 S60",
        "T1 P0",
        "M116",
        "T0 P0",
        "M116",
        "T-1",
        "T0",
        "G21",
        "G90",
        "M83",
        "G92 E0",
        "M107"
    };

    end_gcode = {
        "G1 E-0.8 F2400",
        "M107",
        "G91",
        "G1 Z2 F1000",
        "G90",
        "T-1",
        "G29 S2",
        "G28 X0",
        "M0",
        "M84",
        "M73 P100 R0"
    };
    clear();
}

void Slicer::clear() {
    gcode.clear();
    toolpath.clear();
    post_processed_gcode.clear();
    m_current_position = glm::vec4(0, 0, 0, 0);
    m_last_tool = noTool;
    m_active_tool = noTool;

    actual_max_z = 0;
    numLayers = 0;
    filament_diameter = 1.75;

    m_cumulative_E = 0;
    m_current_feedrate = 1000;
}

void Slicer::load_macro(const std::string& start_path, const std::string& end_path) {
    // Load start gcode
    if (!start_path.empty()) {
        std::ifstream start_file(start_path);
        if (start_file) {
            std::vector<std::string> loaded_start_gcode;
            std::string line;
            while (std::getline(start_file, line)) {
                if (!line.empty()) loaded_start_gcode.push_back(line);
            }
            if (!loaded_start_gcode.empty()) {
                start_gcode = loaded_start_gcode;
            }
        }
    }

    // Load end gcode
    if (!end_path.empty()) {
        std::ifstream end_file(end_path);
        if (end_file) {
            std::vector<std::string> loaded_end_gcode;
            std::string line;
            while (std::getline(end_file, line)) {
                if (!line.empty()) loaded_end_gcode.push_back(line);
            }
            if (!loaded_end_gcode.empty()) {
                end_gcode = loaded_end_gcode;
            }
        }
    }
}

void Slicer::slice() {
    process();
}

void Slicer::process() {
    //append comment header with props settings, use prop.xxx for each samples
    comment("-----------------------------------");
    comment("Generated by Merlin Slicer");
    comment("Filament Diameter: " + std::to_string(filament_diameter) + "mm");
    comment("Number of Layers: " + std::to_string(numLayers));
    comment("-----------------------------------");
    add_gcode("\n");

    //add marcos gcode to the post_processed_gcode before export
    post_processed_gcode.clear();
    for (const auto& line : start_gcode) {
        post_processed_gcode.push_back(line);
    }
    add_gcode("\n");
    // Ajoute le G-code généré principal
    for (const auto& line : gcode) {
        post_processed_gcode.push_back(line);
    }
    add_gcode("\n");
    // Ajoute le end_gcode à la fin
    for (const auto& line : end_gcode) {
        post_processed_gcode.push_back(line);
    }
}

void Slicer::postprocess() {
    // Placeholder for any post-processing steps
}

void Slicer::generateSample(SampleProperty props) {
    Tool Ta = createTool(props.tool_a, props.flow_a, props.retract_a, props.feedrate_a, props.temperature_a);
    Tool Tb = createTool(props.tool_b, props.flow_b, props.retract_b, props.feedrate_b, props.temperature_b);

    float fill_height = props.thickness / 2.0f;
    float xStart = props.x_offset + props.line_width * 0.5 - props.width / 2.0f;
    float xEnd = props.x_offset - props.line_width * 0.5 + props.width / 2.0f;
    float yMin = props.y_offset - fill_height + props.line_width*0.5f;
    float yMax = props.y_offset + fill_height - props.line_width*0.5f;
    float yOverlapMin = props.y_offset - props.line_width * 0.5 - ((props.overlap-1) * props.line_width);
    float yOverlapMax = props.y_offset + props.line_width * 0.5 + ((props.overlap-1) * props.line_width);
    numLayers = static_cast<int>(std::ceil(props.height / props.layer_height));

    int linesPerSection = static_cast<int>(std::ceil((fill_height - props.overlap * props.line_width) / props.line_width)) + props.overlap;
    int overlapLines = props.overlap;

    printSampleHeader(props, numLayers, filament_diameter);

    for (int layer = 0; layer < numLayers; ++layer) {
        float z = props.layer_height * (layer + 1);

        // First pass: one tool
        Tool& toolA = (layer % 2 == 0) ? Ta : Tb;
        printSection(toolA, xStart, xEnd, props, z, layer, yOverlapMax, yOverlapMin, yMin, yMax, linesPerSection, overlapLines, /*isFirstSection=*/true);

        // Second pass: the other tool
        Tool& toolB = (layer % 2 == 0) ? Tb : Ta;
        printSection(toolB, xStart, xEnd, props, z, layer, yOverlapMin, yOverlapMax, yMin, yMax, linesPerSection, overlapLines, /*isFirstSection=*/false);
    }

    retract(1, 2400);
    comment("End of Sample");
}

// Create a tool object from the properties
Tool Slicer::createTool(int id, float flow, float retract, int feedrate, float temp) {
    Tool t;
    t.id = id;
    t.flowrate = flow;
    t.retract_length = retract;
    t.feedrate = feedrate;
    t.temperature = temp;
    return t;
}

// Print the G-code sample header
void Slicer::printSampleHeader(const SampleProperty& props, int numLayers, float filament_diameter) {
    add_gcode("\n");
    comment("-----------------------");
    comment("Start of Sample");
    comment("Sample Name: " + props.name);
    comment("Sample Comment: " + props.comment);
    comment("Filament Diameter: " + std::to_string(filament_diameter) + "mm");
    comment("Number of Layers: " + std::to_string(numLayers));
    comment("X Offset: " + std::to_string(props.x_offset));
    comment("Y Offset: " + std::to_string(props.y_offset));
    comment("Width: " + std::to_string(props.width));
    comment("Height: " + std::to_string(props.height));
    comment("Thickness: " + std::to_string(props.thickness));
    comment("Layer Height: " + std::to_string(props.layer_height));
    comment("Line Width: " + std::to_string(props.line_width));
    comment("Tool A ID: " + std::to_string(props.tool_a));
    comment("Tool B ID: " + std::to_string(props.tool_b));
    comment("Flow A: " + std::to_string(props.flow_a));
    comment("Flow B: " + std::to_string(props.flow_b));
    comment("Retract A: " + std::to_string(props.retract_a));
    comment("Retract B: " + std::to_string(props.retract_b));
    comment("Feedrate A: " + std::to_string(props.feedrate_a));
    comment("Feedrate B: " + std::to_string(props.feedrate_b));
    comment("Temperature A: " + std::to_string(props.temperature_a));
    comment("Temperature B: " + std::to_string(props.temperature_b));
    comment("Overlap: " + std::to_string(props.overlap));
    comment("Overlap Flow Modifier: " + std::to_string(props.overlap_flow_modifier));
    comment("Use Purge Tower: " + std::string(props.use_purge_tower ? "Yes" : "No"));
    comment("Use Alternate Sweep: " + std::string(props.use_alternate_sweep ? "Yes" : "No"));
    comment("Use in to out: " + std::string(props.use_in_to_out ? "Yes" : "No"));
    comment("-----------------------");
    add_gcode("\n");
}

// Print a section for a tool (either first or second pass)
void Slicer::printSection(
    Tool& tool, float xStart, float xEnd, const SampleProperty& props, float z, int layer,
    float yStartA, float yStartB, float yMin, float yMax, int linesPerSection, int overlapLines, bool isFirstSection)
{
    tool_change(tool);
    retract(1, 2400);
    new_layer(z);

    retract(1.4, 2400);
    move(glm::vec4(xStart, props.y_offset, actual_max_z + 5, 0), 0, 30000);
    move(glm::vec4(m_current_position.x, m_current_position.y, z, 0));
    extrude(1.4, 2400);

    int feedrate = tool.feedrate;
    float yStart = (layer % 2 == 0) ? yStartA : yStartB;

    for (int i = 0; i < linesPerSection; ++i) {
        float flow = tool.flowrate;
        float y = computeY(i, layer, props, yStart, yMin, yMax, isFirstSection);

        if (props.use_in_to_out) {
            if (i <= overlapLines) flow *= props.overlap_flow_modifier;
        }
        else {
            if (i >= linesPerSection - overlapLines) flow *= props.overlap_flow_modifier;
        }
        if (layer == 0) flow *= 1.2f;

        float e = compute_e(props.width, flow, props.line_width, props.layer_height);

        if (props.use_alternate_sweep) {
            if (i % 2 == 0) {
                moveXY({ xStart, y }, feedrate);
                moveXYE({ xEnd, y }, e, feedrate);
            }
            else {
                moveXY({ xEnd, y }, feedrate);
                moveXYE({ xStart, y }, e, feedrate);
            }
        }
        else {
            moveXY({ xStart, y }, feedrate);
            moveXYE({ xEnd, y }, e, feedrate);
        }
    }
    retract(1, 2400);
}

// Calculate the y coordinate for the current line
float Slicer::computeY(int i, int layer, const SampleProperty& props, float yStart, float yMin, float yMax, bool isFirstSection) {
    if (props.use_in_to_out) {
        if (isFirstSection)
            return (layer % 2 == 0) ? yStart - i * props.line_width : props.y_offset + i * props.line_width;
        else
            return (layer % 2 == 0) ? yStart + i * props.line_width : props.y_offset - i * props.line_width;
    }
    else {
        if (isFirstSection)
            return (layer % 2 == 0) ? yMin + i * props.line_width : yMax - i * props.line_width;
        else
            return (layer % 2 == 0) ? yMin - i * props.line_width : yMax + i * props.line_width;
    }
}


float Slicer::compute_e(float length, float flow, float line_width, float layer_height) const {
    float filament_area = glm::pi<float>() * pow((filament_diameter / 2.0), 2.0);
    float base_e_per_mm = (line_width * layer_height) / filament_area;
    return base_e_per_mm * flow * length;
}

std::string Slicer::time() const {
    std::ostringstream oss;
    auto t = std::time(nullptr);
    auto tm = *std::localtime(&t);
    oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
    return oss.str();
}

void Slicer::comment(const std::string& comment) {
    gcode.push_back("; " + comment);
}

void Slicer::add_gcode(const std::string& cmd) {
    gcode.push_back(cmd);
}

void Slicer::export_gcode(const std::string& filename) {
    if (post_processed_gcode.empty()) process();
    if (post_processed_gcode.empty()) return;

    std::ofstream out(filename);
    for (const auto& line : post_processed_gcode) {
        out << line << "\n";
    }
    out.close();

    Merlin::Console::info() << "GCode successfully written to " << filename << Merlin::Console::endl;
}

void Slicer::retract(float length, float feedrate_override) {
    glm::vec4 end = m_current_position;
    end.w = -length;
    move(end, feedrate_override);
}

void Slicer::extrude(float length, float feedrate_override) {
    glm::vec4 end = m_current_position;
    end.w = length;
    move(end, feedrate_override);
}

void Slicer::move(glm::vec4 destination, int mode, float feedrate_override) {
    glm::vec4 start = m_current_position;
    glm::vec4 end = destination;
    ToolPath tp = gen_toolpath(start, end, m_active_tool, feedrate_override, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::tool_change(Tool tool) {
    
    if (m_active_tool.id == tool.id) return;

    m_active_tool = tool;
    retract(1.4, 2400);
    move_Z(actual_max_z + 5, 0, 30000);
    add_gcode("T" + std::to_string(tool.id));
    brush();
    ToolPath tpa = gen_toolpath(m_current_position, glm::vec4(330, 240, m_current_position.z, 0), m_active_tool, 30000);
    ToolPath tpb = gen_toolpath(m_current_position, glm::vec4(330, 240, m_current_position.z, 0), m_active_tool, 30000);
    m_current_position = glm::vec4(330, 240, m_current_position.z, 0);
    toolpath.push_back(tpa);
    toolpath.push_back(tpb);
}

void Slicer::move_Z(float destination, int mode, float feedrate) {
    glm::vec4 dest = m_current_position;
    dest.z = destination;
    ToolPath tp = gen_toolpath(m_current_position, dest, m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::moveXY(glm::vec2 destination, int mode, float feedrate) {
    ToolPath tp = gen_toolpath(m_current_position, glm::vec4(destination.x, destination.y, m_current_position.z, 0), m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::moveXYE(glm::vec2 destination, float e, int mode, float feedrate) {
    ToolPath tp = gen_toolpath(m_current_position, glm::vec4(destination.x, destination.y, m_current_position.z, e), m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

int Slicer::getLayer() const{
    return m_current_layer;
}

void Slicer::new_layer(float z) {
    glm::vec4 start = m_current_position;
    glm::vec4 end = m_current_position;
    end.w = 0;
    end.z = z;
    actual_max_z = z > actual_max_z ? z : actual_max_z;

    m_current_layer++;
    ToolPath tp = gen_toolpath(start, end, m_active_tool, m_current_feedrate, 0);
    add_gcode(tp);

    //m_sliced_object.push_back(m_current_layer);
    //m_current_layer.clear();
}

void Slicer::brush() {
    move_Z(actual_max_z + 5, 0);
    add_gcode("M98 Pbrush.g");
    ToolPath tp2 = gen_toolpath(m_current_position, glm::vec4(335, 100, m_current_position.z, 0), m_active_tool, 10000, 0);
    ToolPath tp3 = gen_toolpath(m_current_position, glm::vec4(335, 180, m_current_position.z, 0), m_active_tool, 10000, 0);
    toolpath.push_back(tp2);
    toolpath.push_back(tp3);
    m_current_position = glm::vec4(330, 180, m_current_position.z, 0);
}

ToolPath Slicer::gen_toolpath(const glm::vec4& start, const glm::vec4& end, const Tool& tool, float feedrate_override, int mode) {
    ToolPath tp = ToolPath();
    tp.start = start;
    tp.end = end;

    tp.meta.x = feedrate_override == -1 ? tool.feedrate : feedrate_override;
    tp.meta.y = tool.temperature;
    tp.meta.z = tool.flowrate;
    tp.meta.w = tool.id;
    tp.meta_bis.x = m_current_layer;
    tp.meta_bis.y = mode;
    return tp;
}

void Slicer::add_gcode(ToolPath tp, const std::string& command) {
    std::ostringstream line;
    line << command << " ";

    if (tp.end.x != m_current_position.x) line << "X" << std::fixed << std::setprecision(3) << tp.end.x << " ";
    if (tp.end.y != m_current_position.y) line << "Y" << std::fixed << std::setprecision(3) << std::to_string(tp.end.y) + " ";
    if (tp.end.z != m_current_position.z) line << "Z" << std::fixed << std::setprecision(3) << std::to_string(tp.end.z) + " ";
    if (tp.end.w != 0) line << "E" << std::fixed << std::setprecision(5) << std::to_string(tp.end.w) + " ";
    if (tp.meta.x != m_current_feedrate) line << "F" << std::to_string(int(tp.meta.x)) + " ";

    if (line.str() == command + " ") return;
    m_current_position = tp.end;
    m_current_position.w = 0;
    m_current_feedrate = tp.meta.x;
    gcode.push_back(line.str());
    toolpath.push_back(tp);
}