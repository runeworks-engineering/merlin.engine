#include "Slicer.h"
#include <Merlin.h>
#include <iomanip>
#include <sstream>
#include <ctime>
#include <fstream>





Slicer::Slicer()
    : toolpath(0), noTool({ -1,0,0,10000,0 }) {

    start_gcode = {
        "T-1",
        "G28",
        "G29",
        "G29 S1",
        "G1 Z5 F5000",
        "G10 S220 R215 P0",
        "G10 S230 R235 P1",
        "M190 S60",
        "T1 P0",
        "M116",
        "T0 P0",
        "M116",
        "T-1",
        "T0",
        "G21",
        "G90",
        "M83",
        "G92 E0",
        "M107"
    };

    end_gcode = {
        "G1 E-0.8 F2400",
        "M107",
        "G91",
        "G1 Z2 F1000",
        "G90",
        "T-1",
        "G29 S2",
        "G28 X0",
        "M0",
        "M84",
        "M73 P100 R0"
    };
    clear();
}

void Slicer::clear() {
    gcode.clear();
    toolpath.clear();
    post_processed_gcode.clear();
    m_current_position = glm::vec4(0, 0, 0, 0);
    m_last_tool = noTool;
    m_active_tool = noTool;

    actual_max_z = 0;
    numLayers = 0;
    filament_diameter = 1.75;

    m_cumulative_E = 0;
    m_current_feedrate = 1000;
}

void Slicer::load_macro(const std::string& start_path, const std::string& end_path) {
    // Load start gcode
    if (!start_path.empty()) {
        std::ifstream start_file(start_path);
        if (start_file) {
            std::vector<std::string> loaded_start_gcode;
            std::string line;
            while (std::getline(start_file, line)) {
                if (!line.empty()) loaded_start_gcode.push_back(line);
            }
            if (!loaded_start_gcode.empty()) {
                start_gcode = loaded_start_gcode;
            }
        }
    }

    // Load end gcode
    if (!end_path.empty()) {
        std::ifstream end_file(end_path);
        if (end_file) {
            std::vector<std::string> loaded_end_gcode;
            std::string line;
            while (std::getline(end_file, line)) {
                if (!line.empty()) loaded_end_gcode.push_back(line);
            }
            if (!loaded_end_gcode.empty()) {
                end_gcode = loaded_end_gcode;
            }
        }
    }
}

void Slicer::slice() {
    process();
}

void Slicer::process() {
    //append comment header with props settings, use prop.xxx for each samples
    comment("-----------------------------------");
    comment("Generated by Merlin Slicer");
    comment("Filament Diameter: " + std::to_string(filament_diameter) + "mm");
    comment("Number of Layers: " + std::to_string(numLayers));
    comment("-----------------------------------");
    add_gcode("\n");

    //add marcos gcode to the post_processed_gcode before export
    post_processed_gcode.clear();
    for (const auto& line : start_gcode) {
        post_processed_gcode.push_back(line);
    }
    add_gcode("\n");
    // Ajoute le G-code généré principal
    for (const auto& line : gcode) {
        post_processed_gcode.push_back(line);
    }
    add_gcode("\n");
    // Ajoute le end_gcode à la fin
    for (const auto& line : end_gcode) {
        post_processed_gcode.push_back(line);
    }
}

void Slicer::postprocess() {
    // Placeholder for any post-processing steps
}

void Slicer::generateSample(SampleProperty props) {
    Tool Ta;
    Tool Tb;

    Ta.id = props.tool_a;
    Ta.flowrate = props.flow_a;
    Ta.retract_length = props.retract_a;
    Ta.feedrate = props.feedrate_a;
    Ta.temperature = props.temperature_a; // Example temperature for tool A

    Tb.id = props.tool_b;
    Tb.flowrate = props.flow_b;
    Tb.retract_length = props.retract_b;
    Tb.feedrate = props.feedrate_b;
    Tb.temperature = props.temperature_b; // Example temperature for tool A

    float fill_height = props.thickness / 2.0f;
    float xStart = props.x_offset - props.width / 2;
    float xEnd = props.x_offset + props.width / 2;
    float yMin = props.y_offset - fill_height;
    float yMax = props.y_offset + fill_height;
    float yOverlapMin = props.y_offset - props.overlap * props.line_width / 2.0f;
    float yOverlapMax = props.y_offset + props.overlap * props.line_width / 2.0f;
    numLayers = int(std::ceil(props.height / props.layer_height));

    int linesPerSection = static_cast<int>(std::ceil(fill_height) / props.line_width) + props.overlap;
    int overlapLines = props.overlap;


    add_gcode("\n");
    comment("-----------------------");
    comment("Start of Sample");
    //append comment header with props settings, use prop.xxx for each samples
    comment("Sample Name: " + props.name);
    comment("Sample Comment: " + props.comment);
    comment("Filament Diameter: " + std::to_string(filament_diameter) + "mm");
    comment("Number of Layers: " + std::to_string(numLayers));
    comment("X Offset: " + std::to_string(props.x_offset));
    comment("Y Offset: " + std::to_string(props.y_offset));
    comment("Width: " + std::to_string(props.width));
    comment("Height: " + std::to_string(props.height));
    comment("Thickness: " + std::to_string(props.thickness));
    comment("Layer Height: " + std::to_string(props.layer_height));
    comment("Line Width: " + std::to_string(props.line_width));
    comment("Tool A ID: " + std::to_string(props.tool_a));
    comment("Tool B ID: " + std::to_string(props.tool_b));
    comment("Flow A: " + std::to_string(props.flow_a));
    comment("Flow B: " + std::to_string(props.flow_b));
    comment("Retract A: " + std::to_string(props.retract_a));
    comment("Retract B: " + std::to_string(props.retract_b));
    comment("Feedrate A: " + std::to_string(props.feedrate_a));
    comment("Feedrate B: " + std::to_string(props.feedrate_b));
    comment("Temperature A: " + std::to_string(props.temperature_a));
    comment("Temperature B: " + std::to_string(props.temperature_b));
    comment("Overlap: " + std::to_string(props.overlap));
    comment("Overlap Flow Modifier: " + std::to_string(props.overlap_flow_modifier));
    comment("Use Purge Tower: " + std::string(props.use_purge_tower ? "Yes" : "No"));
    comment("Use Alternate Sweep: " + std::string(props.use_alternate_sweep ? "Yes" : "No"));
    comment("Use in to out: " + std::string(props.use_in_to_out ? "Yes" : "No"));
    comment("-----------------------");
    add_gcode("\n");
    Tool tool = Ta;

    for (int layer = 0; layer < numLayers; ++layer) {
        float z = props.layer_height * (layer + 1);

        // TPU section
        tool = tool.id == Ta.id && layer % 2 == 0 ? Ta : Tb;

        tool_change(tool);

        retract(1, 2400);
        new_layer(z);

        retract(1.4, 2400);
        move(glm::vec4(xStart, props.y_offset, actual_max_z + 5, 0), 0, 30000);
        move(glm::vec4(m_current_position.x, m_current_position.y, z, 0), 17800);
        extrude(1.4, 2400);

        int feedrate = (tool.id == props.tool_a) ? props.feedrate_a : props.feedrate_b;
        float yStart = (layer % 2 == 0) ? yOverlapMax : yOverlapMin;

        for (int i = 0; i < linesPerSection; ++i) {

            float y = 0;
            
            float flow = (tool.id == props.tool_a) ? props.flow_a : props.flow_b;
            if (props.use_in_to_out) {
                y = (layer % 2 == 0) ? yStart - i * props.line_width : props.y_offset + i * props.line_width;
            }
            else {
                y = (layer % 2 == 0) ? yMin + i * props.line_width : yMax - i * props.line_width;
            }


            if (props.use_in_to_out) {
                if (i <= overlapLines) flow *= props.overlap_flow_modifier;
            }
            else {
                if (i >= linesPerSection - overlapLines) flow *= props.overlap_flow_modifier;
            }

            if (layer == 0) flow *= 1.2f;

            float e = compute_e(props.width, flow, props.line_width, props.layer_height);
            std::ostringstream move_cmd;

            if (props.use_alternate_sweep) {
                if (i % 2 == 0) {
                    moveXY({ xStart,y }, feedrate);
                    moveXYE({ xEnd,y }, e, feedrate);
                }
                else {
                    moveXY({ xEnd,y }, feedrate);
                    moveXYE({ xStart,y }, e, feedrate);
                }
            }
            else {
                moveXY({ xStart,y }, feedrate);
                moveXYE({ xEnd,y }, e, feedrate);
            }
        }

        // PLA Section
        retract(1, 2400);
        tool = tool.id == Ta.id && layer % 2 == 0 ? Tb : Ta;

        tool_change(tool);

        feedrate = (tool.id == props.tool_a) ? props.feedrate_a : props.feedrate_b;

        retract(1.4, 2400);
        move(glm::vec4(xStart, props.y_offset, actual_max_z + 5, 0), 0, 30000);
        move(glm::vec4(m_current_position.x, m_current_position.y, z, 0));
        extrude(1.4, 2400);

        yStart = (layer % 2 == 0) ? yOverlapMin : yOverlapMax;

        for (int i = 0; i < linesPerSection; ++i) {
            float flow = (tool.id == props.tool_a) ? props.flow_a : props.flow_b;
            float y = 0;
            if (props.use_in_to_out) {
                y = (layer % 2 == 0) ? yStart + i * props.line_width : props.y_offset - i * props.line_width;
            }
            else {
                y = (layer % 2 == 0) ? yMin - i * props.line_width : yMax + i * props.line_width;
            }

            if (props.use_in_to_out) {
                if (i <= overlapLines) flow *= props.overlap_flow_modifier;
            }
            else {
                if (i >= linesPerSection - overlapLines) flow *= props.overlap_flow_modifier;
            }

            if (layer == 0) flow *= 1.2f;

            float e = compute_e(props.width, flow, props.line_width, props.layer_height);

            if (props.use_alternate_sweep) {
                if (i % 2 == 0) {
                    moveXY({ xStart,y }, feedrate);
                    moveXYE({ xEnd,y }, e, feedrate);
                }
                else {
                    moveXY({ xEnd,y }, feedrate);
                    moveXYE({ xStart,y }, e, feedrate);
                }
            }
            else {
                moveXY({ xStart,y }, feedrate);
                moveXYE({ xEnd,y }, e, feedrate);
            }

        }
    }

    retract(1, 2400);
    comment("End of Sample");
}

float Slicer::compute_e(float length, float flow, float line_width, float layer_height) const {
    float filament_area = glm::pi<float>() * pow((filament_diameter / 2.0), 2.0);
    float base_e_per_mm = (line_width * layer_height) / filament_area;
    return base_e_per_mm * flow * length;
}

std::string Slicer::time() const {
    std::ostringstream oss;
    auto t = std::time(nullptr);
    auto tm = *std::localtime(&t);
    oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
    return oss.str();
}

void Slicer::comment(const std::string& comment) {
    gcode.push_back("; " + comment);
}

void Slicer::add_gcode(const std::string& cmd) {
    gcode.push_back(cmd);
}

void Slicer::export_gcode(const std::string& filename) {
    if (post_processed_gcode.empty()) process();
    if (post_processed_gcode.empty()) return;

    std::ofstream out(filename);
    for (const auto& line : post_processed_gcode) {
        out << line << "\n";
    }
    out.close();

    Merlin::Console::info() << "GCode successfully written to " << filename << Merlin::Console::endl;
}

void Slicer::retract(float length, float feedrate_override) {
    glm::vec4 end = m_current_position;
    end.w = -length;
    move(end, feedrate_override);
}

void Slicer::extrude(float length, float feedrate_override) {
    glm::vec4 end = m_current_position;
    end.w = length;
    move(end, feedrate_override);
}

void Slicer::move(glm::vec4 destination, int mode, float feedrate_override) {
    glm::vec4 start = m_current_position;
    glm::vec4 end = destination;
    ToolPath tp = gen_toolpath(start, end, m_active_tool, feedrate_override, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::tool_change(Tool tool) {
    
    if (m_active_tool.id == tool.id) return;

    m_active_tool = tool;
    retract(1.4, 2400);
    move_Z(actual_max_z + 5, 0, 30000);
    add_gcode("T" + std::to_string(tool.id));
    brush();
    ToolPath tpa = gen_toolpath(m_current_position, glm::vec4(330, 240, m_current_position.z, 0), m_active_tool, 30000);
    ToolPath tpb = gen_toolpath(m_current_position, glm::vec4(330, 240, m_current_position.z, 0), m_active_tool, 30000);
    m_current_position = glm::vec4(330, 240, m_current_position.z, 0);
    toolpath.push_back(tpa);
    toolpath.push_back(tpb);
}

void Slicer::move_Z(float destination, int mode, float feedrate) {
    glm::vec4 dest = m_current_position;
    dest.z = destination;
    ToolPath tp = gen_toolpath(m_current_position, dest, m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::moveXY(glm::vec2 destination, int mode, float feedrate) {
    ToolPath tp = gen_toolpath(m_current_position, glm::vec4(destination.x, destination.y, m_current_position.z, 0), m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::moveXYE(glm::vec2 destination, float e, int mode, float feedrate) {
    ToolPath tp = gen_toolpath(m_current_position, glm::vec4(destination.x, destination.y, m_current_position.z, e), m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

int Slicer::getLayer() const{
    return m_current_layer;
}

void Slicer::new_layer(float z) {
    glm::vec4 start = m_current_position;
    glm::vec4 end = m_current_position;
    end.w = 0;
    end.z = z;
    actual_max_z = z > actual_max_z ? z : actual_max_z;

    m_current_layer++;
    ToolPath tp = gen_toolpath(start, end, m_active_tool, m_current_feedrate, 0);
    add_gcode(tp);

    //m_sliced_object.push_back(m_current_layer);
    //m_current_layer.clear();
}

void Slicer::brush() {
    move_Z(actual_max_z + 5, 0);
    add_gcode("M98 Pbrush.g");
    ToolPath tp2 = gen_toolpath(m_current_position, glm::vec4(335, 100, m_current_position.z, 0), m_active_tool, 10000, 0);
    ToolPath tp3 = gen_toolpath(m_current_position, glm::vec4(335, 180, m_current_position.z, 0), m_active_tool, 10000, 0);
    toolpath.push_back(tp2);
    toolpath.push_back(tp3);
    m_current_position = glm::vec4(330, 180, m_current_position.z, 0);
}

ToolPath Slicer::gen_toolpath(const glm::vec4& start, const glm::vec4& end, const Tool& tool, float feedrate_override, int mode) {
    ToolPath tp = ToolPath();
    tp.start = start;
    tp.end = end;

    tp.meta.x = feedrate_override == -1 ? tool.feedrate : feedrate_override;
    tp.meta.y = tool.temperature;
    tp.meta.z = tool.flowrate;
    tp.meta.w = tool.id;
    tp.meta_bis.x = m_current_layer;
    tp.meta_bis.y = mode;
    return tp;
}

void Slicer::add_gcode(ToolPath tp, const std::string& command) {
    std::ostringstream line;
    line << command << " ";

    if (tp.end.x != m_current_position.x) line << "X" << std::fixed << std::setprecision(3) << tp.end.x << " ";
    if (tp.end.y != m_current_position.y) line << "Y" << std::fixed << std::setprecision(3) << std::to_string(tp.end.y) + " ";
    if (tp.end.z != m_current_position.z) line << "Z" << std::fixed << std::setprecision(3) << std::to_string(tp.end.z) + " ";
    if (tp.end.w != 0) line << "E" << std::fixed << std::setprecision(5) << std::to_string(tp.end.w) + " ";
    if (tp.meta.x != m_current_feedrate) line << "F" << std::to_string(int(tp.meta.x)) + " ";

    if (line.str() == command + " ") return;
    m_current_position = tp.end;
    m_current_position.w = 0;
    m_current_feedrate = tp.meta.x;
    gcode.push_back(line.str());
    toolpath.push_back(tp);
}