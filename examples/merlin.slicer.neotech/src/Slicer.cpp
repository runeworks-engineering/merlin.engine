#include "Slicer.h"
#include <Merlin.h>
#include <iomanip>
#include <sstream>
#include <ctime>
#include <fstream>

Slicer::Slicer()
    : toolpath(0), noTool({ -1,0,2400,0 }) {

    start_gcode = {
        "%1000",
        "G90",
        "G17",
        "HOME_EXTRUDER_AXES",
        "SHIFT_MOVING_FRAME[102.043,119.692,-15.062]",
        "PS2 F1000",
        "G04 0.5",
        "BED_LEVELING[22, 80.0, 0.0, 0.0, 5.944]",
        "G0 Z30",
        "TOOLID[15]",
        "G0 QA=0 QB=0",
        "G0 X0 Y0",
        "G90",
        "M82",
        "SET_EXTRUDER_AXES[0.0,0.0,0.0,0.0]"
    };

    end_gcode = {
        "SET_EXTRUDER_AXES[0.0,0.0,0.0,0.0]",
        "G90",
        "G17",
        "PS2 F1000"
        "HOME_EXTRUDER_AXES"
    };




    clear();
}

void Slicer::clear() {
    gcode.clear();
    toolpath.clear();
    post_processed_gcode.clear();
    m_current_position = glm::vec4(0, 0, 0, 0);
    m_last_tool = noTool;
    m_active_tool = noTool;

    actual_max_z = 0;
    numLayers = 0;
    filament_diameter = 1.75;

    m_cumulative_E = 0;
    m_current_feedrate = 1000;
}

void Slicer::load_macro(const std::string& start_path, const std::string& end_path) {
    // Load start gcode
    if (!start_path.empty()) {
        std::ifstream start_file(start_path);
        if (start_file) {
            std::vector<std::string> loaded_start_gcode;
            std::string line;
            while (std::getline(start_file, line)) {
                if (!line.empty()) loaded_start_gcode.push_back(line);
            }
            if (!loaded_start_gcode.empty()) {
                start_gcode = loaded_start_gcode;
            }
        }
    }

    // Load end gcode
    if (!end_path.empty()) {
        std::ifstream end_file(end_path);
        if (end_file) {
            std::vector<std::string> loaded_end_gcode;
            std::string line;
            while (std::getline(end_file, line)) {
                if (!line.empty()) loaded_end_gcode.push_back(line);
            }
            if (!loaded_end_gcode.empty()) {
                end_gcode = loaded_end_gcode;
            }
        }
    }
}

void Slicer::slice() {
    process();
}

void Slicer::process() {
    //append comment header with props settings, use prop.xxx for each samples
    comment("-----------------------------------");
    comment("Generated by Merlin Slicer");
    comment("Filament Diameter: " + std::to_string(filament_diameter) + "mm");
    comment("Number of Layers: " + std::to_string(numLayers));
    comment("-----------------------------------");
    add_gcode("\n");

    //add marcos gcode to the post_processed_gcode before export
    post_processed_gcode.clear();
    for (const auto& line : start_gcode) {
        post_processed_gcode.push_back(line);
    }
    add_gcode("\n");
    // Ajoute le G-code généré principal
    for (const auto& line : gcode) {
        post_processed_gcode.push_back(line);
    }
    add_gcode("\n");
    // Ajoute le end_gcode à la fin
    for (const auto& line : end_gcode) {
        post_processed_gcode.push_back(line);
    }
}

void Slicer::postprocess() {
    // Placeholder for any post-processing steps
}

void Slicer::generateSample(SampleProperty props) {
    Tool tool;

    tool.id = props.tool;
    tool.flowrate = props.flow;
    tool.retract_length = props.retract;
    tool.feedrate = props.feedrate;

    if (props.sample_type < 2) numLayers = int(std::ceil(props.height / props.layer_height));
    else numLayers = 1;

    m_active_tool = tool;
    m_current_feedrate = props.feedrate;

    add_gcode("\n");
    comment("-----------------------");
    comment("Start of Sample");
    // Append comment header with props settings
    comment("Sample Name: " + props.name);
    comment("Sample Comment: " + props.comment);
    comment("Filament Diameter: " + std::to_string(filament_diameter) + "mm");
    comment("Number of Layers: " + std::to_string(numLayers));
    comment("X Offset: " + std::to_string(props.x_offset));
    comment("Y Offset: " + std::to_string(props.y_offset));
    comment("Radius: " + std::to_string(props.radius));
    comment("Height: " + std::to_string(props.height));
    comment("Layer Height: " + std::to_string(props.layer_height));
    comment("Line Width: " + std::to_string(props.line_width));
    comment("Tool ID: " + std::to_string(props.tool));
    comment("Flow: " + std::to_string(props.flow));
    comment("Retract: " + std::to_string(props.retract));
    comment("Feedrate: " + std::to_string(props.feedrate));
    comment("Sample Type: " + std::to_string(props.sample_type));
    comment("Use outline: " + std::to_string(props.use_outline));
    comment("-----------------------");
    add_gcode("\n");

    for (int layer = 0; layer < numLayers; ++layer) {
        float z = props.layer_height * (layer + 1);

        //retract(1, 2400);
        

        //retract(1.4, 2400);
        extrude(1.4, 2400);
        move(glm::vec4(props.x_offset, props.y_offset, actual_max_z + 5, 0), 0, 7800);
        new_layer(z);
        move(glm::vec4(m_current_position.x, m_current_position.y, z, 0), 1, 17800);
        

        if (props.sample_type == 0) generateConcentric(props);
        else if (props.sample_type == 1) generateSpiral(props);
        else generateLineTest(props);

        // PLA Section
        //retract(1, 2400);
    }
    move_Z(actual_max_z + 5, 0, 7800);
    //retract(1, 2400);
    comment("End of Sample");
}

void Slicer::generateLineTest(SampleProperty props){
    float x = props.length, y = 0;
    glm::vec3 next = glm::vec3(props.x_offset, props.y_offset, 0) + glm::vec3(x, y, m_current_position.z);
    float e = compute_e(glm::distance(glm::vec3(m_current_position), next), props.flow, props.line_width, props.layer_height);
    move(glm::vec4(next, e));

    x = props.length, y = props.height;
    next = glm::vec3(props.x_offset, props.y_offset, 0) + glm::vec3(x, y, m_current_position.z);
    e = compute_e(glm::distance(glm::vec3(m_current_position), next), props.flow, props.line_width, props.layer_height);
    move(glm::vec4(next, e));
}

void Slicer::generateSpiral(SampleProperty props) {
    const float pi = glm::pi<float>();
    float a = 0; // starting radius
    float b = props.line_width / (2 * pi); // spiral growth rate so spacing is correct
    
    float theta = 0;
    float x0 = 0;
    float y0 = 0;
    
    float r = pi / 12.0f;
    while (true) {
        // Compute next theta based on arc length spacing
        float dTheta = props.resolution * (r / props.radius) / sqrt(b*b + (b * theta)*(b * theta));
        theta += dTheta;

        r = a + b * theta;
        float x = r * cos(theta);
        float y = r * sin(theta);

        // Stop if we go beyond a certain radius
        if (props.use_outline)
            if (r + props.line_width > props.radius) break;

        if (!props.use_outline)
            if (r > props.radius) break;

        glm::vec3 next = glm::vec3(props.x_offset, props.y_offset, 0) + glm::vec3(x, y, m_current_position.z);
        float e = compute_e(glm::distance(glm::vec3(m_current_position), next), props.flow, props.line_width, props.layer_height);
        move(glm::vec4(next, e));
        //points.add(new PVector(x, y));
    }

    float dTheta = props.resolution / 4.0 * props.radius / sqrt(b * b + (b * theta) * (b * theta));
    if (props.use_outline){
        for (float gamma = theta; gamma < theta + pi * 2.0; gamma += dTheta) {

            float x = (props.radius - props.line_width * 0.2) * cos(gamma);
            float y = (props.radius - props.line_width * 0.2) * sin(gamma);

            glm::vec3 next = glm::vec3(props.x_offset, props.y_offset, 0) + glm::vec3(x, y, m_current_position.z);
            float e = compute_e(glm::distance(glm::vec3(m_current_position), next), props.flow, props.line_width, props.layer_height);
            move(glm::vec4(next, e));
        }
    }
}

void Slicer::generateConcentric(SampleProperty props){

    int n = static_cast<int>(props.radius / props.line_width);
    float alpha = 0.0f;
    float pi = glm::pi<float>();
    float x = 0;
    float y = 0;

    for (int i = 0; i < n; ++i) {
        if (alpha == 0.0f) {
            alpha += props.line_width;
            continue;
        }

        float inc = std::asin(std::min(1.0f, props.resolution * 0.5f / alpha));

        for (float theta = 0.0f; theta < 2.0f * pi; theta += inc) {
            x = std::cos(theta) * alpha;
            y = std::sin(theta) * alpha;

            glm::vec3 next = glm::vec3(props.x_offset, props.y_offset, 0) + glm::vec3(x, y, m_current_position.z);
            float e = compute_e(glm::distance(glm::vec3(m_current_position), next), props.flow, props.line_width, props.layer_height);
            move(glm::vec4(next, e));
        }

        glm::vec3 next = glm::vec3(props.x_offset, props.y_offset, 0) + glm::vec3(x, y, m_current_position.z + 1);
        move(glm::vec4(next, 0));

        alpha += props.line_width;
        x = alpha;
        next = glm::vec3(props.x_offset, props.y_offset, 0) + glm::vec3(x, y, m_current_position.z);
        move(glm::vec4(next, 0));
        next = glm::vec3(props.x_offset, props.y_offset, 0) + glm::vec3(x, y, m_current_position.z - 1);
        move(glm::vec4(next, 0));
    }  
}

float Slicer::compute_e(float length, float flow, float line_width, float layer_height) const {
    float filament_area = glm::pi<float>() * pow((filament_diameter / 2.0), 2.0);
    float base_e_per_mm = (line_width * layer_height) / filament_area;
    return base_e_per_mm * flow * length;
}

std::string Slicer::time() const {
    std::ostringstream oss;
    auto t = std::time(nullptr);
    auto tm = *std::localtime(&t);
    oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
    return oss.str();
}

void Slicer::comment(const std::string& comment) {
    gcode.push_back("(" + comment + ")");
}

void Slicer::add_gcode(const std::string& cmd) {
    gcode.push_back(cmd);
}

void Slicer::export_gcode(const std::string& filename) {
    if (post_processed_gcode.empty()) process();
    if (post_processed_gcode.empty()) return;

    std::ofstream out(filename);
    for (const auto& line : post_processed_gcode) {
        out << line << "\n";
    }
    out.close();

    Merlin::Console::info() << "GCode successfully written to " << filename << Merlin::Console::endl;
}

void Slicer::retract(float length, float feedrate_override) {
    glm::vec4 end = m_current_position;
    end.w = -length;
    move(end, feedrate_override);
}

void Slicer::extrude(float length, float feedrate_override) {
    glm::vec4 end = m_current_position;
    end.w = length;
    move(end, feedrate_override);
}

void Slicer::move(glm::vec4 destination, int mode, float feedrate_override) {
    glm::vec4 start = m_current_position;
    glm::vec4 end = destination;
    ToolPath tp = gen_toolpath(start, end, m_active_tool, feedrate_override, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::tool_change(Tool tool) {
    
    if (m_active_tool.id == tool.id) return;

    m_active_tool = tool;
    retract(1.4, 2400);
    move_Z(actual_max_z + 5, 0, 7800);
    add_gcode("TOOLID[" + std::to_string(tool.id) + "]");
    //brush();
    ToolPath tpa = gen_toolpath(m_current_position, glm::vec4(330, 240, m_current_position.z, 0), m_active_tool, 7800);
    ToolPath tpb = gen_toolpath(m_current_position, glm::vec4(330, 240, m_current_position.z, 0), m_active_tool, 7800);
    m_current_position = glm::vec4(330, 240, m_current_position.z, 0);
    toolpath.push_back(tpa);
    toolpath.push_back(tpb);
}

void Slicer::move_Z(float destination, int mode, float feedrate) {
    glm::vec4 dest = m_current_position;
    dest.z = destination;
    ToolPath tp = gen_toolpath(m_current_position, dest, m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::moveXY(glm::vec2 destination, int mode, float feedrate) {
    ToolPath tp = gen_toolpath(m_current_position, glm::vec4(destination.x, destination.y, m_current_position.z, 0), m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

void Slicer::moveXYE(glm::vec2 destination, float e, int mode, float feedrate) {
    ToolPath tp = gen_toolpath(m_current_position, glm::vec4(destination.x, destination.y, m_current_position.z, e), m_active_tool, feedrate, mode);
    add_gcode(tp, mode == 0 ? "G0" : "G1");
}

int Slicer::getLayer() const{
    return m_current_layer;
}

void Slicer::new_layer(float z) {
    glm::vec4 start = m_current_position;
    glm::vec4 end = m_current_position;
    end.w = 0;
    end.z = z;
    actual_max_z = z > actual_max_z ? z : actual_max_z;

    m_current_layer++;
    
    ToolPath tp = gen_toolpath(start, end, m_active_tool, m_current_feedrate, 0);
    add_gcode(tp);

    add_gcode("SET_EXTRUDER_AXES[0.0,0.0,0.0,0.0]");
    m_current_position.w = 0;
    
    //m_sliced_object.push_back(m_current_layer);
    //m_current_layer.clear();
}

void Slicer::brush() {
    move_Z(actual_max_z + 5, 0);
    add_gcode("M98 Pbrush.g");
    ToolPath tp2 = gen_toolpath(m_current_position, glm::vec4(335, 100, m_current_position.z, 0), m_active_tool, 2400, 0);
    ToolPath tp3 = gen_toolpath(m_current_position, glm::vec4(335, 180, m_current_position.z, 0), m_active_tool, 2400, 0);
    toolpath.push_back(tp2);
    toolpath.push_back(tp3);
    m_current_position = glm::vec4(330, 180, m_current_position.z, 0);
}

ToolPath Slicer::gen_toolpath(const glm::vec4& start, const glm::vec4& end, const Tool& tool, float feedrate_override, int mode) {
    ToolPath tp = ToolPath();
    tp.start = start;
    tp.end = end;

    tp.meta.x = feedrate_override == -1 ? tool.feedrate : feedrate_override;
    tp.meta.y = 0;
    tp.meta.z = tool.flowrate;
    tp.meta.w = tool.id;
    tp.meta_bis.x = m_current_layer;
    tp.meta_bis.y = mode;
    return tp;
}

void Slicer::add_gcode(ToolPath tp, const std::string& command) {
    std::ostringstream line;
    line << command << " ";

    if (tp.end.x != m_current_position.x) line << "X" << std::fixed << std::setprecision(3) << tp.end.x << " ";
    if (tp.end.y != m_current_position.y) line << "Y" << std::fixed << std::setprecision(3) << std::to_string(tp.end.y) + " ";
    if (tp.end.z != m_current_position.z) line << "Z" << std::fixed << std::setprecision(3) << std::to_string(tp.end.z + z_offset) + " ";
    if (tp.end.w != 0) line << "QV=" << std::fixed << std::setprecision(5) << std::to_string(m_current_position.w + tp.end.w) + " ";
    if (tp.meta.x != m_current_feedrate) line << "F" << std::to_string(int(tp.meta.x)) + " ";

    if (line.str() == command + " ") return;
    m_current_position = tp.end + glm::vec4(0,0,0,m_current_position.w);
    m_current_feedrate = tp.meta.x;
    gcode.push_back(line.str());
    toolpath.push_back(tp);
}