//?#version 430

#pragma once
//?#include "../common/uniforms.comp"
//?#include "../common/constants.comp"
//?#include "../common/buffers.comp"
//?#include "../common/nns.comp"
//?#include "sph.kernels.comp" 
//?#include "boundary.comp" 

float computeTemperatureDelta(uint i) {

	float temperatureDelta = 0.0;
	vec3 position = b_pi.xyz;
	bool isInNozzle = false;

	vec4 nozzle = u_emitterTransform * vec4(0,0,0,1);
	if ((b_pi.z > nozzle.z && distance(nozzle.xy, b_pi.xy) < 20))
		isInNozzle = true;

	OVERNNS
		if(j == i || c_Dij < 1e-6 || c_Dij > H) continue;
		float rhoj = mj / (3.1415926*(4/3)*pow(cst_particleRadius,3));
		float lambda = 1.0e-3;//( 0.13 / (1590  * rhoj));
		
		if(phase(j) == BOUNDARY+1){
			temperatureDelta += 30.0*lambda*(b_Tj-b_Ti)/(c_Dij*1e-3);
			isInNozzle = true;
		}else{
			temperatureDelta += lambda*(b_Tj-b_Ti)/(c_Dij*1e-3);
		}
	OVERNNS_END
	//temperatureDelta /= float(n);
	
	//vec3 nozzle_position = (u_emitterTransform * vec4(0,0,0,1.0)).xyz;


	if(!isInNozzle){
		temperatureDelta += 5000.0 * (298.15 - b_Ti)*u_dt; //fan
	}else temperatureDelta += 900.0 * (298.15 - b_Ti)*u_dt; //losses

	if(isnan(temperatureDelta)) return 0;
	return temperatureDelta;
}