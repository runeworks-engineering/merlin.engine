#version 430

#pragma once
#include "../../common/shaders/colors.comp"
#include "../common/uniforms.comp"
#include "../common/constants.comp"
#include "../common/buffers.comp"
#include "../common/nns.comp"
#include "sph.kernels.comp" 

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (rgba16f, binding = 0) writeonly uniform image2D u_output;

uniform int colorMode = 3;
uniform int colorMapSelection = 0;
uniform float offsetPlane = 0;

float interpolate(in vec3 position){
	float density = 0;

	OVERNNS
		float dist = distance(b_xj.xyz, position);
		if(dist > H) continue;
		float Wij = poly6(dist);

		if(phase(j) == FLUID || phase(j) == SOLID)
			density += mj * Wij*3.9;
	OVERNNS_END
	return density;
}


float interpolatePhase(in vec3 position){
	float est_phase = 0;

	OVERNNS
		float dist = distance(b_xj.xyz, position);
		if(dist > H) continue;
		float Wij = poly6(dist);

		if(phase(j) == FLUID)
			est_phase -= mj * Wij;
		if(phase(j) == SOLID)
			est_phase += mj * Wij;
	OVERNNS_END
	return est_phase;
}

float interpolateHeat(in vec3 position){
	float temp = 0;

	OVERNNS
		float dist = distance(b_xj.xyz, position);
		if(dist > H) continue;
		float Wij = poly6(dist);
		if(phase(j) == SOLID || phase(j) == FLUID){
			temp += b_Tj * Wij*0.3; //pseudo mass, 
		}
	OVERNNS_END
	return temp;
}


uniform vec3 axis;
uniform vec3 offset;

void main(){
    ivec2 dims = imageSize(u_output).xy;
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy) + ivec2(0,-50);

	vec2 uv = vec2(pixel_coords) / vec2(dims);
	vec2 position = vec2(0);
	float temp = 0;
	float est_phase = 0;
	float density = 0;

	vec3 worldPos = vec3(0);
	if(axis == vec3(1,1,0)){
		uv.x = uv.x - 0.5f;
		uv.y = uv.y - 0.5f;
		position = uv * vec2(cst_domain.xy);
		worldPos = vec3(position.x, position.y, 0 + offsetPlane) + offset;

	}else if(axis == vec3(1,0,1)){
		uv.x = uv.x - 0.5f;
		position = uv * vec2(cst_domain.xz);
		worldPos = vec3(position.x, 0 + offsetPlane, position.y) + offset;

	}else if(axis == vec3(0,1,1)){
		uv.x = uv.x - 0.5f;
		position = uv * vec2(cst_domain.yz);
		worldPos = vec3(0 + offsetPlane, position.x, position.y) + offset;
	}



	float minValue = 0;
	float maxValue = 0;
	float value = 0;

	density = interpolate(worldPos);
	temp = interpolateHeat(worldPos);
	est_phase = interpolatePhase(worldPos);

	Palette palette = inferno;



	if(colorMapSelection == 0)
		palette = inferno;
	else if(colorMapSelection == 1)
		palette = blackbody;
	else if(colorMapSelection == 2)
		palette = plasma;
	else if(colorMapSelection == 3)
		palette = viridis;
	else if(colorMapSelection == 4)
		palette = warmcool;
	else if(colorMapSelection == 5)
		palette = parula;
	else if(colorMapSelection == 6)
		palette = jet;
		


	if(colorMode == 0){ // solid color
		imageStore(u_output, pixel_coords, vec4(1,0.2,0.2,density));
		return;
	}else if(colorMode == 1){ // bin index
		uint binI = getBinIndex(worldPos);
		imageStore(u_output, pixel_coords, vec4(randomColor(binI).rgb,density));
		return;
	}else if(colorMode == 2){ // density
		value = density;
		minValue = 1000 * u_rho0;
		maxValue =  1050 * u_rho0;
	}else if(colorMode == 3){ // Temperature
		value = temp;
		minValue = 275;
		maxValue =  275+200.0;
	}else if(colorMode == 4){ // Phase
		value = est_phase;
		minValue = -1;
		maxValue =  1;
		
	}else if(colorMode == 5){ // solid color
		value = temp;
		minValue = 275;
		maxValue =  275+300.0;
	}else if(colorMode == 6){ // solid color
		value = temp;
		minValue = 275;
		maxValue =  275+300.0;
	}

	imageStore(u_output, pixel_coords, vec4(colorMap(map(value,minValue,maxValue), palette).rgb, density));
	


	return;

}