//?#version 430

#pragma once
//?#include "../common/uniforms.comp"
//?#include "../common/constants.comp"
//?#include "../common/buffers.comp"
//?#include "../common/nns.comp"
//?#include "sph.kernels.comp" 
//?#include "boundary.comp" 

float pbf_computeLambda(uint i);
vec3 pbf_computePositionDelta(uint i);
vec3 pbf_computeXPSH(uint i);
vec3 computeViscosityForce(uint i);
void applyViscosityConstraint(uint i);

//#define USE_ONLY_POSITIVE_PRESSURE

vec3 solveParticleCollision(uint i){
	
	vec3 deltaPosition = vec3(0);
	vec3 xi = b_pi.xyz;
	vec3 position = xi;
	int n = 0;

	OVERNNS
		if(!(phase(j) >= BOUNDARY /*|| phase(j) == SOLID*/)) continue;
		if(i == j) continue;
		float dist = c_Dij;
		if(dist < EPSILON && dist > H) continue;

		vec3 xj = b_xj.xyz;

		float ri, rj;
		ri = rj = cst_particleRadius * 1.0;
		
		// Compute the constraint C
		vec3 xij = xi - xj;
		
		float C = dist - (ri + rj);
		

		//if (C < 0.0) { // Only apply correction if there is a collision
			// Compute the gradient of the constraint
			//vec3 grad_i = xij / dist;
			vec3 grad_i = normalize(xij);
			vec3 grad_j = -grad_i;

			// Compute the Lagrange multiplier update
			float wi = 1.0 / mi;
			float wj = 1.0 / mj;
			//float grad_norm2 = wi * dot(grad_i, grad_i) + wj * dot(grad_j, grad_j); //Magnitude or gradient are 1 so it simplify
			float grad_norm2 = wi + wj;
			float alpha = 0.0001; // Compliance parameter, should be set appropriately
			
			//float delta_lambda = -(C + alpha * b_lambda_j) / (grad_norm2 + alpha);
			float delta_lambda = -C / (grad_norm2 + alpha);
			//b_lambda_j += delta_lambda;

			// Apply position corrections
			deltaPosition = wi * delta_lambda * grad_i;
			n++;
		//}

	OVERNNS_END

	//if(n > 1) deltaPosition = deltaPosition/float(n);

	float relaxation = 0.1;

	return relaxation * deltaPosition;
}

void pbf_step(uint i, uint kernel) {
	if(kernel == 0){
		b_last_xi = b_xi;
		b_xi = b_pi;
		vec3 a = vec3(0, 0, -u_g);

		//semi-implicit Euler integration (or Sympletic scheme)
		b_vi.xyz += 0.5* a * u_dt;
		b_vi.xyz -= computeViscosityForce(i) * u_dt;
		b_pi.xyz += 0.998*b_vi.xyz * u_dt;
		
		return;
	}

	if(kernel == 1){ //compute lagrange multiplier
		//b_lambda_i = clamp(pbf_computeLambda(i), -0.1*H, 0.1*H);
		b_lambda_i = pbf_computeLambda(i);
		//b_vi.xyz -= computeViscosityForce(i) * u_dt;
		return;
	}
		
	if(kernel == 2){//correct density error and update position
		b_dpi.xyz = pbf_computePositionDelta(i);
		//b_vi.xyz -= computeViscosityForce(i) * u_dt;
		//b_dpi.xyz += solveParticleCollision(i);
		b_dpi.xyz += boundary_solveFloorCollision(i);
		


		//particles[i].pposition = clampToDomain(particles[i].pposition);
		return;
	}

	if(kernel == 3){//apply XSPH velocity correction
		vec3 corr = b_dpi.xyz;
		if(isnan(corr.x) || isnan(corr.y) || isnan(corr.z)) corr = vec3(0);

		//applyViscosityConstraint(i);
		b_pi.xyz += corr;

		//b_vi.xyz = (b_pi.xyz - b_xi.xyz)/u_dt; // First order velocity update
		b_vi.xyz = (1.0/u_dt) * (1.5*b_pi.xyz - 2.0* b_xi.xyz + 0.5*b_last_xi.xyz); // Second order velocity update
		vec3 a = vec3(0, 0, -u_g);
		b_vi.xyz += 0.5 * a * u_dt; // Add remaining half gravity
		b_vi.xyz -= computeViscosityForce(i) * u_dt;
		b_vi.xyz = boundary_dampFloorCollision(i);
		
		//sigma_i = mat4(visco_computeViscoStress(i));
		return;
	}

	if(kernel == 4){//apply XSPH velocity correction
		//b_dpi.xyz = pbf_computeXPSH(i);
		//b_vi.xyz += b_dpi.xyz;
		b_vi.xyz += pbf_computeXPSH(i);
		b_vi.xyz -= computeViscosityForce(i) * u_dt;
		if(b_xi.z < 3.0*cst_particleRadius) b_vi.xyz *= 0.1;
		return;
	}

	if(kernel == 5){//apply XSPH velocity correction
		vec3 corr = computeViscosityForce(i) * u_dt;
		if(isnan(corr.x) || isnan(corr.y) || isnan(corr.z)) corr = vec3(0);
		b_vi.xyz -= corr;
		
		return;
	}
}

void applyViscosityConstraint(uint i) {
	vec3 xi = b_pi.xyz;
	vec3 vi = b_vi.xyz;
	vec3 xi_star = xi + vi * u_dt;

	vec3 totalCorrection = vec3(0);
	float totalWeight = 0;
	vec3 position = b_pi.xyz;
	OVERNNS
		if (j == i) continue;
		if (c_Dij < EPSILON || c_Dij > H) continue;

		vec3 vj = b_vj.xyz;
		vec3 xj = b_pj.xyz;
		vec3 xj_star = xj + vj * u_dt;

		vec3 vij = vi - vj;
		float Wij = poly6(c_Rij);

		// Apply only if they differ
		if (length(vij) < EPSILON) continue;

		// Viscosity constraint weight (can be phase-aware)
		float weight = Wij;
		switch(phase(j)) {
			case FLUID: case SOLID: weight *= 1.0; break;
			case BOUNDARY: weight *= 1.0; break;
			case BOUNDARY+1: weight *= 1.0; break;
		}

		// Symmetric position correction
		vec3 correction = -0.5 * 0.1 * weight * vij * u_dt;
		
		//b_pj.xyz -= correction;
		totalCorrection += correction;
		totalWeight += weight;
	OVERNNS_END
	b_pi.xyz += totalCorrection;
	// Optional convergence or stability metrics
}


vec3 pbf_computeXPSH(uint i){
	vec3 xsphSum = vec3(0);
	vec3 position = b_pi.xyz;

	OVERNNS
		if (j == i) continue;
		if (c_Dij < EPSILON || c_Dij > H) continue;

		vec3 vji = c_Vji;
		float Wij = poly6(c_Rij);

		// Clamp relative velocity
		const float maxVel = 200.0 * H;
		float vji_mag = length(vji);
		if (vji_mag > maxVel) 
			vji *= (maxVel / vji_mag); // optional

		// Directional damping (more stable)
		vec3 dir = normalize(c_Rij);
		float v_dot = dot(vji, dir);

		float rho_ij = 0.5 * (b_rho_i + b_rho_j);
		if (rho_ij < EPSILON) continue;

		float multiplier = u_artificialViscosityMultiplier;

		// Phase-aware control
		switch(phase(j)) {
			case FLUID:
			case SOLID:
				multiplier *= 1.0;
				break;
			case BOUNDARY:
			case BOUNDARY+1:
				multiplier *= 1.0;
				break;
		}

		vec3 xsph = multiplier * v_dot * dir * Wij / rho_ij;
		xsphSum += xsph;
	OVERNNS_END

	const float maxValue = 800.0 * H;
	xsphSum = clamp(xsphSum, vec3(-maxValue), vec3(maxValue));
	return xsphSum;
}



vec3 computeViscosityForce(uint i) {
	vec3 viscSum = vec3(0);
	vec3 vi = b_vi.xyz;
	vec3 xi = b_pi.xyz;
	vec3 position = b_pi.xyz;
	const float eta2 = 0.01f * H * 0.01f * H;
	const float maxVel = 3000.0f * H;

	OVERNNS
		if (j == i) continue;
		if (c_Dij < EPSILON || c_Dij > H) continue;
		if (phase(j) != FLUID) continue;

		vec3 vj = b_vj.xyz;
		vec3 xj = b_pj.xyz;
		vec3 xij = xi - xj;
		vec3 vij = vi - vj;

		// Clamp relative velocity
		float vji_mag = length(vij);
		if (vji_mag > maxVel) 
			vij *= (maxVel / vji_mag);

		// Optional directional damping (project along xij)
		vec3 dir = normalize(xij);
		float v_dot = dot(vij, dir);
		vec3 dampedVij = v_dot * dir;

		// Symmetric density
		float rho_ij = 0.5f * (b_rho_i + b_rho_j);
		if (rho_ij < EPSILON) continue;

		float Wij = poly6(c_Rij); // or spiky kernel

		float m_j = mj;

		// Phase-aware viscosity scaling
		float multiplier = u_viscosity*10.0;
		switch(phase(j)) {
			case FLUID:
			case SOLID: 
				multiplier *= 1.0;
				break;
			case BOUNDARY:
			case BOUNDARY+1:
				multiplier *= 1.0; // or even higher
				break;
		}

		// Laplacian-like formulation with damping
		vec3 visc = multiplier /* * (m_j / rho_ij)*/ * dampedVij * (Wij / (dot(xij, xij) + eta2));
		if(isnan(visc.x) || isnan(visc.y) || isnan(visc.z)) continue;
			viscSum += visc;
	OVERNNS_END

	// Final clamping for stability
	const float maxVisc = 80000.0f * H;
	viscSum = clamp(viscSum, vec3(-maxVisc), vec3(maxVisc));
	return viscSum;
}




float pbf_computeLambda(uint i) {
    float rho0 = u_rho0;
    float sumGradCj = 0;
    vec3 gradCi = vec3(0);
    float density = 0.0;
    vec3 position = b_xi.xyz;

    OVERNNS
		float dist = c_Dij;
		if(dist > H) continue;

		vec3 diff = c_Rij;
		vec3 gradCj = spiky_grad(diff);

		if(phase(j) == FLUID || phase(j) == SOLID){
			gradCi += mj * gradCj;
		}/*
		else if (phase(j) == SOLID){
			if(b_rho_j > EPSILON)
			gradCi += 20.0*mj * gradCj;
		}*/else if (phase(j) >= BOUNDARY){
			if(b_rho_j > EPSILON)
				gradCi +=(1.0/b_rho_j) * gradCj;
		}/**/
		
		if(i != j && dist > EPSILON){
			if(phase(j) == FLUID|| phase(j) == SOLID){
				sumGradCj += dot(gradCj, gradCj);
				density += mj * poly6(dist);
			}
			/*
			else if (phase(j) == SOLID){
				density += 10.0 * 0.7*(rho0/b_rho_j) * 2.0 * poly6(dist);
				vec3 gradCk = 10.0*(1.0/b_rho_j) * 2.0 *  gradCj;
				sumGradCj += dot(gradCk, gradCk);
			}*/
			else if (phase(j) >= BOUNDARY){
				density += 0.2* poly6(dist);
				if(b_rho_j > EPSILON){

					density += 0.1*(rho0/b_rho_j) * poly6(dist);
					vec3 gradCk = (1.0/b_rho_j) * gradCj;
					sumGradCj += dot(gradCk, gradCk);
					
				}
			}/**/
		}
		
	OVERNNS_END



	sumGradCj += dot(gradCi, gradCi);
	sumGradCj = max(sumGradCj, EPSILON);

	#ifdef USE_ONLY_POSITIVE_PRESSURE
		b_rho_i = max(density, rho0);
		float C = max((density / rho0) - 1.0, 0.0);
	#else
		b_rho_i = density;
		float C = (density / rho0) - 1.0;
	#endif

	    //return - ((1.0/mi) * C) / (sumGradCj/pow(rho0, 2) + EPSILON);
    //return -C / (sumGradCj/pow(rho0, 2) + EPSILON);
	float compliance = 0.00001;
	float alpha = compliance / (u_dt*u_dt);   // e.g. compliance = 1e-6
	return -C / (sumGradCj + alpha + EPSILON);
}




//Compute position deltas w neigbor
vec3 pbf_computePositionDelta(uint i) {
	vec3 posDelta = vec3(0.0f);
	float rho0 = u_rho0;
	float sCorr = 0.0;
	
	#ifdef USE_ONLY_POSITIVE_PRESSURE
		if(b_rho_i -  u_rho0 < 0) return posDelta;
	#endif

	//float closestSDF = 0.0;
	//float closestSDF_distance = 10000.0;
	//vec3 closestSDF_grad = vec3(0);
	
	vec3 sumSDFGrad = vec3(0.0);
	float sumSDFWeight = 0.0;
	uint numNeihbors = 0;

	vec3 position = b_xi.xyz;
	OVERNNS
		//if(j == i) continue;
		float dist = c_Dij;
		if(dist > H || dist < EPSILON) continue;

		sCorr = -u_artificialPressureMultiplier * H2 * pow(poly6(dist) / poly6(normalize(vec3(1)) * 0.2*H), 4);
		//sCorr = -u_artificialPressureMultiplier * pow(poly6(dist) / poly6(normalize(vec3(1)) * 0.2*H), 4);

		if(phase(j) == FLUID || phase(j) == SOLID){
			//posDelta += (spiky_grad(c_Rij) * (b_lambda_i + b_lambda_j + sCorr)) / rho0;
			
			if(j != i)
				posDelta += spiky_grad(c_Rij) * (b_lambda_i + b_lambda_j + sCorr);
			else 
				posDelta += spiky_grad(c_Rij) * (b_lambda_i + b_lambda_i + sCorr);
			
		}else if( phase(j) >= BOUNDARY && sCorr <0){
			if(j != i && spiky(c_Rij) > 0)
				posDelta += 0.5*spiky_grad(c_Rij) * (b_lambda_i + sCorr);

			//SDF Correction averaging
			//vec4 sdf = b_dpj;
			
			//sumSDFWeight += b_dpj.w * poly6(c_Dij);
			

			/*
			if(c_Dij < closestSDF_distance) {
				closestSDF = b_dpj.w;
				closestSDF_grad = b_dpj.xyz;
				closestSDF_distance = c_Dij;
			}/**/
			
			/**/
			if(c_Dij > 0.2*H) {
				numNeihbors ++;
				sumSDFGrad += b_dpj.xyz * poly6(c_Dij); // push out
				sumSDFWeight += b_dpj.w;
			}/**/



		}else if(phase(j) == SOLID){
			if(j != i)
				posDelta += 1.0*spiky_grad(c_Rij) * (b_lambda_i + 0.0*sCorr);
		}
		/*
		else if(phase(j) == SOLID){
			posDelta += 0.1*spiky_grad(c_Rij) * (1.0/b_rho_j) * (2.0 * b_lambda_i + sCorr);
		}
		else if(phase(j) >= BOUNDARY){
			posDelta += 0.1*spiky_grad(c_Rij) * (1.0/b_rho_j) * (2.0 * b_lambda_i + sCorr);
		}/**/

	OVERNNS_END
	posDelta /= rho0;

	//SDF Correction
	float stiffness = 2.0; // 0 = no correction, 1 = full projection
	sumSDFWeight /= float(numNeihbors);

	if (sumSDFWeight > 0.0) {
	//if (closestSDF > 0.0) {
		posDelta -= stiffness * normalize(sumSDFGrad) * sumSDFWeight;
		//posDelta -= stiffness * normalize(closestSDF_grad) * closestSDF;
	}

	//posDelta = clamp(posDelta, -MAX_DELTA_PI, MAX_DELTA_PI);
	return posDelta * 0.2;
}
