//? #version 430
#ifndef INCLUDE_NNS_GLSL
#define INCLUDE_NNS_GLSL
//?#include "../common/buffers.comp"
//?#include "../common/constants.comp"

uvec3 getBinCoord(vec3 position) {
    vec3 rel = position - cst_boundaryMin;
    ivec3 cell = ivec3(floor((rel) / cst_binSize));
    ivec3 clamped = clamp(cell, ivec3(0), ivec3(cst_binMax) - ivec3(1));
    return uvec3(clamped);
}

uint getBinIndexFromCoord(uvec3 coord) {
	return (coord.z * cst_binMax.x * cst_binMax.y) + (coord.y * cst_binMax.x) + coord.x;
}

uint getBinIndex(vec3 position) {
	uvec3 bin3D = getBinCoord(position);
    return getBinIndexFromCoord(bin3D);
}

uvec3 getBinCoordFromIndex(uint index) {
	uint z = index / (cst_binMax.x * cst_binMax.y);
	index -= (z * cst_binMax.x * cst_binMax.y);
	uint y = index / cst_binMax.x;
	uint x = index % cst_binMax.x;
	return uvec3(x, y, z);
}


#define OVERNNS_END }}}}}

#define OVERNNS {\
ivec3 c = ivec3(getBinCoord(position));\
ivec3 minB = max(c - ivec3(1), ivec3(0));\
ivec3 maxB = min(c + ivec3(1), ivec3(cst_binMax) - ivec3(1));\
for (int z = minB.z; z <= maxB.z; ++z) {\
  for (int y = minB.y; y <= maxB.y; ++y) {\
    for (int x = minB.x; x <= maxB.x; ++x) {\
			uint cindex = getBinIndexFromCoord(uvec3(x, y, z));\
			if (ssbo_bins[cindex].count == 0) continue;\
			for (uint j = ssbo_bins[cindex].sum - ssbo_bins[cindex].count; j < min(ssbo_bins[cindex].sum, ssbo_bins[cindex].sum - ssbo_bins[cindex].count + MAXNN); j++) {\
				if (j >= u_numParticles) continue;


#endif// INCLUDE_BUFFERS_HLSL